<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Mapa de Recinto Alfandegado</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icone.png">
    <!-- Leaflet CSS 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.css">   
     
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <!-- MarkerCluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css" />
  <style>
  :root {
    --azul: #2196F3;
    --azul-escuro: #0D47A1;
    --cinza-claro: #f1f1f1;
    --fonte: Arial, sans-serif;
  }

  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: var(--fonte);
  }


  /* ===============================
    MAPA E √çCONES FIXOS
  =============================== */
  #map {
    height: 100%;
    width: 100%;
    position: relative;
  }

  #flaticon-icon {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 10000;
  }
  #flaticon-icon img {
    width: 32px;
    height: 32px;
  }

  #map-title {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: transparent;
    padding: 5px 15px;
    border-radius: 5px;
    font-weight: bold;
    font-size: 1.8rem;
    color: var(--azul);
    z-index: 1000;
  }

  /* ===============================
    RODAP√â
  =============================== */
  .map-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: transparent;
    padding: 6px 10px;
    font-size: 0.7rem;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    z-index: 1000;
  }
  .map-footer-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .map-footer-item img {
    height: 20px;
  }

    /* ===============================
      PAINEL LATERAL  height: 900px,
    =============================== */
  .painel-tabela {
    position: absolute;
    top: 50px;
    right: 10px;
    width: 60%;
    height: 700px !important;


    background: #fff;
    border: 2px solid var(--azul-escuro);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    overflow: auto; /* mant√©m rolagem vertical e horizontal */
    display: none;
    z-index: 1000;
    padding: 10px;
    font-size: 0.5rem;
    min-width: 900px;
  }
  .painel-tabela .fechar {
    float: right;
    cursor: pointer;
    font-weight: bold;
    color: darkred;
    margin-bottom: 10px;
  }
  .painel-tabela h2 {
    margin: 0 0 8px 0;
    font-size: 0.8rem;
    color: var(--azul-escuro);
  }
  .painel-tabela .table-wrapper {
    overflow-x: auto; /* for√ßa rolagem horizontal */
    overflow-y: auto; /* for√ßa rolagem vertical */
    max-height: none; /* n√£o limita altura */
    border: 1px solid #ddd;
  }

  /* ===============================
    TABELA
  =============================== */
  .painel-tabela table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; /* for√ßa caber na largura */
    font-size: 0.65rem;  /* fonte menor */
  }

  .painel-tabela th,
  .painel-tabela td {
    padding: 2px 4px;
    border: 1px solid #ddd;
    text-align: center;
    white-space: normal; /* permite quebra */
    word-wrap: break-word;
  }
  .painel-tabela thead {
    background: var(--cinza-claro);
    color: #000;
    font-weight: bold;
    position: sticky;
    top: 0;
    z-index: 2;
  }
  .painel-tabela tbody tr:nth-child(even) {
    background: #f9f9f9;
  }
  .painel-tabela tbody tr:hover {
    background: #e3f2fd;
  }

  /* Colunas fixas */
  .painel-tabela table th:nth-child(1),
  .painel-tabela table td:nth-child(1) { width: 35px; }
  .painel-tabela table th:nth-child(2),
  .painel-tabela table td:nth-child(2) { width: 50px; }
  .painel-tabela table th:nth-child(3),
  .painel-tabela table td:nth-child(3) { width: 20px; }
  .painel-tabela table th:nth-child(4),
  .painel-tabela table td:nth-child(4) { width: 35px; }
  .painel-tabela table th:nth-child(5),
  .painel-tabela table td:nth-child(5) { width: 20px; }
  .painel-tabela table th:nth-child(6),
  .painel-tabela table td:nth-child(6) { width: 80px; }
  .painel-tabela table th:nth-child(7),
  .painel-tabela table td:nth-child(7) { width: 90px; }
  .painel-tabela table th:nth-child(8),
  .painel-tabela table td:nth-child(8) { width: 80px; }
  /* üì± Mobile */
  @media (max-width: 768px) {
    .painel-tabela {
      top: 0;
      right: 0;
      width: 100%;
      height: 100vh; /* ocupa toda a tela */
      min-width: unset; /* remove largura m√≠nima */
      font-size: 0.7rem;
      border-radius: 0; /* painel colado nas bordas */
    }

    .painel-tabela table {
      min-width: 600px; /* for√ßa scroll horizontal */
      font-size: 0.65rem;
    }

    .painel-tabela th,
    .painel-tabela td {
      padding: 2px 4px;
      font-size: 0.65rem;
    }

    .dataTable-pagination .dataTable-pagination-button {
      font-size: 0.55rem;
      padding: 1px 4px;
    }
  }
  /* ===============================
    BOT√ïES
  =============================== */

  .btn-acao,
  .btn-plotar,
  .btn-editar {
    background: linear-gradient(180deg, #2196F3, #1565C0);
    border: 1px solid #0D47A1;
    border-radius: 4px;
    color: #fff;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 0.7rem;
    box-shadow: 0 2px #0D47A1;
    margin-right: 6px;
  }
  .btn-fechar {
    background: transparent;   /* sem fundo */
    border: none;              /* sem borda */
    padding: 4px;
    cursor: pointer;
  }

  .btn-fechar:hover {
    background: #f5f5f5;       /* leve destaque ao passar o mouse */
    border-radius: 4px;
  }

  .icon-fechar {
    width: 20px;
    height: 20px;
    display: block;
  }

  .btn-acao:active,
  .btn-plotar:active,
  .btn-editar:active {
    box-shadow: 0 1px #0D47A1;
    transform: translateY(1px);
  }

  /* Estilo do alerta */
  .alert-box {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;          /* fundo branco */
    color: #d32f2f;            /* texto vermelho */
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 9999;
    border: 2px solid #d32f2f; /* borda vermelha opcional */
  }

  .alert-box.show {
    opacity: 1;
  }

  .alert-box.alert-error {
    /* se quiser diferenciar erros, pode refor√ßar borda ou sombra */
    box-shadow: 0 0 10px #d32f2f;
  }

  /* Remove o X do campo de busca */
  input[type="search"]::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
  }

  /* Campo de busca em azul */
  .dataTable-input {
    padding: 2px 3px;
    border: 1px solid #2196f3; /* azul */
    border-radius: 4px;
    font-size: 10px;
    outline: none;
    transition: all 0.3s ease;
  }

  .dataTable-input:focus {
    border-color: #0d47a1;
    box-shadow: 0 0 6px rgba(33, 150, 243, 0.5);
  }

  /* Remove o X do campo de busca */
  .dataTable-input::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
  }

  /* Bot√µes de pagina√ß√£o */
  .dataTable-pagination .dataTable-pagination-button {
    background: #2196f3; /* azul */
    color: white;
    border: none;
  font-size: 0.65rem;
  padding: 1px 4px;
    margin: 1px;
    border-radius: 2px;
    cursor: pointer;
    transition: background 0.3s ease;
  }

  .dataTable-pagination .dataTable-pagination-button:hover {
    background: #1976d2; /* azul mais escuro */
  }

  .dataTable-pagination .dataTable-pagination-button.active {
    background: #0d47a1; /* azul ainda mais escuro */
    font-weight: bold;
  }


  /* ===============================
    LABELS E POPUPS
  =============================== */
  .polygon-label {
    font-weight: bold;
    font-size: 0.65rem;
    color: #000;
    background: transparent;
    border: none;
    box-shadow: none;
  }
  .popup-transparente .leaflet-popup-content-wrapper,
  .popup-transparente .leaflet-popup-tip {
    background: transparent;
    box-shadow: none;
    border: none;
  }
  .popup-table {
    max-height: 300px;
    overflow: auto;
  }
  .text-label {
    font-size: 0.9rem;
    font-weight: bold;
    color: darkblue;
    background: rgba(255,255,255,0.7);
    padding: 2px 6px;
    border-radius: 4px;
  }
  .tooltip-transparent {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    color: var(--azul);
    font-weight: bold;
  }

  /* ===============================
    UPLOAD
  =============================== */
  #uploadIcon {
    position: fixed;
    top: 20px;
    right: 20px;
    cursor: pointer;
    text-align: center;
  }
  #uploadIcon svg {
    width: 32px;
    height: 32px;
    fill: var(--azul);
  }
  #fileCSV { display: none; }

  .leaflet-control-custom,
  .leaflet-control-upload {
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
  }
  .leaflet-control-custom {
    font-size: 1.2rem;
    padding: 5px;
  }
  .leaflet-control-upload {
    padding: 4px;
  }
  .leaflet-control-upload svg {
    width: 28px;
    height: 28px;
    fill: var(--azul);
  }

  /* ===============================
    POPUP TRANSPARENTE
  =============================== */
  .leaflet-popup-content-wrapper {
    background: rgba(255,255,255,0.75);
    box-shadow: none;
    border: none;
  }

  
  .bounce-in { animation: bounce-in 220ms ease-out both; }
  @keyframes bounce-in {
    0%   { transform: translateY(-8px); opacity: 0.7; }
    60%  { transform: translateY(2px);  opacity: 1;   }
    100% { transform: translateY(0); }
  }

  /* Bot√£o Principal e Op√ß√µes */

  /* Container do Menu (posi√ß√£o fixa do bot√£o e popup absoluto) */
  .cursor-menu-container {
      position: relative;   /* refer√™ncia para o popup absoluto */
      display: inline-block;
  }

  /* Bot√£o principal e bot√µes das op√ß√µes (retangulares) */
  .cursor-btn {
      background-color: rgba(255, 255, 255, 0.9);
      border: 2px solid darkblue;
      border-radius: 4px;
      cursor: pointer;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: 0.2s ease;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }

  /* üëá √çcones em darkblue */
  .cursor-btn i {
      color: darkblue !important;    /* for√ßa a cor */
      font-size: 18px;
  }

  /* Hover: muda apenas o fundo, mant√©m o √≠cone em darkblue */
  .cursor-btn:hover {
      background-color: rgba(0, 0, 139, 0.10); /* leve destaque; opcional */
      transform: translateY(-1px);
  }
  .cursor-btn:hover i {
      color: darkblue !important;    /* garante que continue darkblue no hover */
  }

  /* Popup de op√ß√µes absoluto (n√£o empurra o bot√£o) */
  .cursor-options {
      position: absolute;
      right: 48px;                    /* dist√¢ncia em rela√ß√£o ao bot√£o */
      top: 50%;
      transform: translateY(-50%);
      display: none;
      flex-direction: row;            /* troque para 'column' se preferir vertical */
      gap: 8px;
      padding: 6px 8px;
      background: rgba(255, 255, 255, 0.92);
      border: 2px solid darkblue;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
  }


  /* Cor do Zoom solicitada anteriormente */
  .leaflet-bar { border: 2px solid darkblue !important; }
  .leaflet-bar a { color: darkblue !important; }

  /* Estilo do T√≠tulo (Topo Esquerda) */
  .custom-map-title h2 { 
      color: darkblue; 
      margin: 10px; 
      font-family: 'Arial', sans-serif;
      text-shadow: 1px 1px 2px white;
  }
  </style>
</head>

<body>
  <p id="siglaRecinto"></p>

  <input type="file" id="fileCSV" accept=".csv,text/csv">

  <div id="map">
      <div id="flaticon-icon">
        <a href="https://www.flaticon.com/br/" title="Flaticon" target="_blank">
          <img 
            src="https://www.flaticon.com/media/img/flaticon-logo.svg"
            alt="Flaticon logo">
        </a>

      </div>

  </div>
  <div id="map-title"></div>

  <div id="painelTabela" class="painel-tabela" style="display:none;
      position:absolute; top:50px; right:10px; width:400px; height:300px;
      background:#fff; border:1px solid #ccc; overflow:auto; z-index:9999;">
    <button onclick="fecharPainel()" class="btn-acao btn-fechar" title="Fechar" style="float:right; margin:5px;">
      <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
          alt="Fechar" class="icon-fechar" style="width:20px;height:20px;">
    </button>
    <div class="table-wrapper"></div>
  </div>


  <!-- Leaflet JS 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  -->

  <script src="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.js"></script>

   
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.min.js"></script>
  <script>
    //Vari√°veis e constantes globais
    let idDataTable = null; // vari√°vel global
    let linhaReferencia = null; // guarda √≠ndice da √∫ltima linha clicada
    const separador = ";"; //Separador de arquivo csv
    let mapa;
    let marcadorUsuario;
    const nivelZoom = 18;

    // Array para armazenar coordenadas das casas
    let poligonoRecinto = []; 
      
    // JSON com array de 5 itens
    const infoArea = [
      { titulo: "√Årea:", icone: "", cor: 'navy' },                   
      { titulo: "Recinto", icone: "", cor: 'navy' },
                        ];    
    const areas = [
      { coords: [], titulo: "Posicionamento de Ve√≠culo", cor: 'darkcyan' },
      { coords: [], titulo: "Armazenamento de Lotes", cor: 'green' },
      { coords: [], titulo: "Controle de Carga Solta", cor: 'purple' },
      { coords: [], titulo: "Posicionamento de Cont√™iner",cor: 'red' },
      { coords: [], titulo: "Confer√™ncia F√≠sica", cor: 'orange' },
      { coords: [], titulo: "Port√™iner, Shiploader ou similares", cor: 'black' },
      { coords: [], titulo: "Port√™iner Shiploader ou similares", cor: 'black' }          
                        ];   

    // Estado da fun√ß√£o de inibir apresenta√ß√£o de coordenadas no mapa
    let clickEnabled = false;
    isTracing = true; //Mostra dados na console
    // Grupo de clusters
    let markersCluster ;
    let tabelaGeo = [{Tipo: "", Equipamento: "", Ativo: false, Azimute: 0, Longitude: 0, Latitude: 0}];      
   // 1. DEFINI√á√ÉO DOS TILES (MAPAS)
    const sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis
                           maxNativeZoom: 18});
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis
                          maxNativeZoom: 18});
          
    // Mapas base gratuitos
    const baseMaps = {
                        "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                          attribution: "¬© OpenStreetMap",    
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 18
                        }),
                        "Carto Light": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png", {
                          attribution: "¬© Carto",    
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 17
                        }),
                        "Carto Dark": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{r}.png", {
                          attribution: "¬© Carto", 
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 17
                        }),
                        "Esri World": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}", {
                          attribution: "Tiles ¬© Esri",
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis
                          
                          maxNativeZoom: 18
                        }),
                        // ‚úÖ Sat√©lite Esri
                        "Esri Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
                          attribution: "Tiles ¬© Esri & the GIS community",
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 18
                        }),
                        "Sentinel-2 cloudless":L.tileLayer('https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2020_3857/default/GoogleMapsCompatible/{z}/{y}/{x}.jpg', {
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 16,  // Avisa que as fotos reais s√≥ v√£o at√© ao 16 (estica a imagem ap√≥s isso)
                          attribution: 'Sentinel-2 cloudless - https://s2maps.eu by EOX IT Services GmbH'
                        }),
                        'Google Maps': L.tileLayer('https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}', {
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis

                          maxNativeZoom: 20, // O Google costuma ter fotos reais at√© o 20 em √°reas urbanas
                          subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
                          attribution: 'Google Maps'
                        }),
                        'Google Sat' : L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
                          maxZoom: 22,        // n√≠veis m√°ximos suportados pela fonte
                          minZoom: 0,
                          tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
                          zoomOffset: 0,      // ajuste se usar 512px tiles
                          detectRetina: true, // usa tiles retina quando dispon√≠veis
                          subdomains:['mt0','mt1','mt2','mt3']
                        })


    }

    // √çcones ideais para cada mapa
    const baseMapIcons = {
        "OpenStreetMap": "üó∫Ô∏è",       // mapa gen√©rico
        "Carto Light": "üåû",          // estilo claro
        "Carto Dark": "üåô",           // estilo escuro
        "Esri World": "üåç",           // mapa de ruas/mundo
        "Esri Satellite": "üõ∞Ô∏è"       // sat√©lite
      };  

    //Mapa
    let map;

    // Controle customizado
    let popupAberto = false;
    let popupRef = null;
              
    const STORAGE_KEY = 'plotarGeoreferenciamento'; // <‚Äî ajuste para a sua chave
    const TOOLTIP_ENABLED  = 'Upload de arquivo CSV';
    const TOOLTIP_DISABLED = 'Upload desabilitado: j√° h√° dados carregados';
 
  
  

    let tabAux  = lerDoStorage(STORAGE_KEY)
    let geoLocalizacaoRecinto = lerDoStorage("geoLocalizacaoRecinto")
    let geoLocalizacaoRecintos = lerDoStorage("geoLocalizacaoRecintos")
//console.log(geoLocalizacaoRecinto)
    const tituloMapa = geoLocalizacaoRecinto ? gerarTitulo(geoLocalizacaoRecinto) : '';
 

    tabelaGeo = tabAux ? tabAux : tabelaGeo
    let azimuteLayer;
   
    inicializaMapa(tituloMapa);
    map.whenReady(() => {
      azimuteLayer = L.layerGroup().addTo(map);
     // adicionarMarcadorLeaflet(map, geoLocalizacaoRecinto    )  
      plotarTabelaGeorreferencimento(tabelaGeo, map);
      // LayerGroup que vai receber todos os gr√°ficos
      
      if(geoLocalizacaoRecintos) 
         plotarRecintos(geoLocalizacaoRecintos, map);
    });

  

    /**
     * Gera o texto do t√≠tulo (tooltip/label) para o mapa.
     * Ex.: "DAWLOG - 7951102"
     */
    function gerarTitulo(ponto) {
      const sigla = (ponto.Sigla ?? "").trim();
      const codigo = (ponto.C√≥digo ?? "").trim();
      return [sigla, codigo].filter(Boolean).join(" - ");
    }

    function isDataInStorage() {
      try {
        const v = localStorage.getItem(STORAGE_KEY);
        // considere n√£o-vazio como ‚Äúh√° dados‚Äù (ajuste conforme seu formato)
        return v != null && String(v).trim().length > 0;
      } catch (e) {
        console.warn('LocalStorage inacess√≠vel:', e);
        return false;
      }
    }    
    function lerDoStorage(chave) {
      console.log('lerdostorage',chave)
        try {
        const valor = localStorage.getItem(chave);
        return valor ? JSON.parse(valor) : null;
        } catch (erro) {
        console.error("Erro ao ler do storage:", erro);
        return null;
        }
    }
    
    function gerarTabelaHTML(tabela) {
      if (!tabela || tabela.length === 0 || tabela[0].Tipo === '') {
        return "";
      }

      // Utilit√°rio para evitar quebra de HTML ao inserir strings
      const esc = s => String(s || "").replace(/'/g, "&#39;").replace(/"/g, "&quot;");

      let html = `
        <!-- Bot√µes no topo -->
        <div class="tabela-actions" style="margin-bottom:8px;">
          <button onclick="criarLinha()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/1665/1665680.png" 
                alt="Nova linha" style="width:12px;height:12px;">
          </button>            
          <button onclick="baixarCSV()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/12809/12809885.png" 
                alt="Salvar csv" style="width:12px;height:12px;">
          </button>
          <button onclick="fecharPainel()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
                alt="Fechar" class="icon-fechar" style="width:12px;height:12px;">
          </button> 
        </div>

        <table id="containerTabelaGeo">
          <thead>
            <tr>
              <th>Tipo</th>
              <th>Equipamento</th>
              <th>Ativo</th>              
              <th>Protocolo</th>
              <th>Azimute</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Plotar</th> 
              <th>Editar</th>
            </tr>
          </thead>
          <tbody>
      `;

      tabela.forEach((p, idx) => {
        const azimute = p.Azimute ? p.Azimute : 0.;
        const tipo = p.Tipo || "";
        const protocoloCompleto = p.Protocolo || "";
        const protocoloCurto = protocoloCompleto.slice(-6);

        const latCompleta = p.Latitude || "";
        const latCurta = latCompleta.slice(-10); // 10 caracteres

        const lonCompleta = p.Longitude || "";
        const lonCurta = lonCompleta.slice(-10); // 10 caracteres

        // Equipamento: remover todas as ocorr√™ncias de Tipo (case-insensitive)
        const equipamentoCompleto = p.Equipamento || "";
        const eqCurtoCalc = (() => {
          if (!tipo) return equipamentoCompleto;
          const re = new RegExp(tipo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); // escape + case-insensitive
          const removido = equipamentoCompleto.replace(re, '').trim();
          if (removido) return removido;
          // fallback: se ficou vazio, mostra uma vers√£o curta √∫til
          return equipamentoCompleto.length > 10 ? equipamentoCompleto.slice(-10) : equipamentoCompleto;
        })();

        html += `
          <tr data-index="${idx}">
            <td>${esc(tipo)}</td>
            <td onclick="mostrarEquipamento(this, '${esc(equipamentoCompleto)}', '${esc(tipo)}')"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(eqCurtoCalc)}
            </td>
            <td contenteditable="true" onblur="tabelaGeo[${idx}].Ativo=this.innerText">${esc(p.Ativo)}</td>
            <td onclick="mostrarProtocolo(this, '${esc(protocoloCompleto)}')"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(protocoloCurto)}
            </td>
            <td contenteditable="true" onblur="tabelaGeo[${idx}].Azimute=this.innerText">${esc(p.Azimute)}</td>
            <td onclick="mostrarLatLon(this, '${esc(latCompleta)}', 10)"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(latCurta)}
            </td>
            <td onclick="mostrarLatLon(this, '${esc(lonCompleta)}', 10)"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(lonCurta)}
            </td>
            <td style="text-align:left;">
              <button onclick="plotarNoMapa('${esc(p.Latitude)}', '${esc(p.Longitude)}', '${esc(p.Tipo)}', '${esc(p.Equipamento)}', ${azimute}, ${idx})" class="btn-acao btn-fechar">üìç</button>
            </td>
            <td style="text-align:left;">
              <button onclick="editarLinha(${idx})" class="btn-acao btn-fechar" title="Editar linha">‚úèÔ∏è</button>
            </td>
          </tr>
        `;
      });

      html += `</tbody></table>`;

      // Bot√µes no rodap√©
      html += `
        <div class="tabela-actions" style="margin-top:8px;">
          <button onclick="criarLinha()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/1665/1665680.png" 
                alt="Nova linha" style="width:20px;height:20px;">
          </button>            
          <button onclick="baixarCSV()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/12809/12809885.png" 
                alt="Salvar csv" style="width:20px;height:20px;">
          </button>
          <button onclick="fecharPainel()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
                alt="Fechar" class="icon-fechar">
          </button>           
        </div>
      `;

      return html;
    }
    function mostrarProtocolo(td, valorCompleto) {
      td.innerText = (td.innerText === valorCompleto)
        ? valorCompleto.slice(-6)
        : valorCompleto;
    }

    function mostrarLatLon(td, valorCompleto, n = 10) {
      td.innerText = (td.innerText === valorCompleto)
        ? valorCompleto.slice(-n)
        : valorCompleto;
    }

    function mostrarEquipamento(td, valorCompleto, tipo) {
      const curto = (() => {
        if (!tipo) return valorCompleto;
        const re = new RegExp(tipo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        const removido = valorCompleto.replace(re, '').trim();
        if (removido) return removido;
        return valorCompleto.length > 10 ? valorCompleto.slice(-10) : valorCompleto;
      })();

      td.innerText = (td.innerText === valorCompleto)
        ? curto
        : valorCompleto;
    }

    function fecharPainel() {
      limparBusca();
      const painel = document.getElementById("painelTabela");
      if (painel) painel.style.display = "none";
    }

    function editarLinha(index) {
      const tabela = document.querySelector("#containerTabelaGeo");
      if (!tabela) {
        console.error("Tabela n√£o encontrada");
        return;
      }

      // Seleciona a linha pelo data-index
      const row = tabela.querySelector(`tbody tr[data-index="${index}"]`);
      if (!row) {
        console.error("Linha n√£o encontrada para √≠ndice:", index);
        return;
  }

      const cells = row.querySelectorAll("td");

      // Torna todas as c√©lulas (exceto Plotar e Editar) edit√°veis
      for (let i = 0; i < cells.length - 2; i++) {
        cells[i].setAttribute("contenteditable", "true");
        cells[i].style.backgroundColor = "#ffffcc"; // destaque amarelo
        cells[i].style.textAlign = "left";          // üëâ alinhamento √† esquerda
      }

      // Troca bot√£o para salvar
      const btnEditar = cells[cells.length - 1].querySelector("button");
      if (btnEditar) {
        btnEditar.innerText = "üíæ";
        btnEditar.onclick = function() { salvarLinha(index); };
      }
    }

    function mostrarAlerta(mensagem) {
      const alerta = document.createElement("div");
      alerta.className = "alert-box";

      // Se come√ßar com "Erro", adiciona √≠cone ‚ö†Ô∏è
      if (mensagem.trim().toLowerCase().startsWith("erro")) {
        alerta.innerHTML = `‚ö†Ô∏è ${mensagem}`;
      } else {
        alerta.textContent = mensagem;
      }

      document.body.appendChild(alerta);

      setTimeout(() => alerta.classList.add("show"), 10);

      setTimeout(() => {
        alerta.classList.remove("show");
        setTimeout(() => alerta.remove(), 300);
      }, 3000);
    }

    // Fun√ß√£o para salvar linha editada
    function salvarLinha(index) {
      const tabela = document.querySelector("#containerTabelaGeo");
      const row = tabela.querySelector(`tbody tr[data-index="${index}"]`);
      if (!row) return;

      const cells = row.querySelectorAll("td");
      const campos = ["Tipo","Equipamento","Ativo","Protocolo","Azimute","Latitude","Longitude"];

      // Normaliza leitura do Tipo uma √∫nica vez
      const tipoTexto = (cells[0]?.textContent || "").trim().toLowerCase();
      const tipoAtual = removerAcentos(tipoTexto); // "poligono" ou "ponto"
      

      for (let i = 0; i < campos.length; i++) {
        let valor = (cells[i]?.textContent || "").trim();

        // Valida√ß√µes b√°sicas (mantidas)
        if (["Tipo","Equipamento","Ativo","Latitude","Longitude"].includes(campos[i]) && valor === "") {
          mostrarAlerta(`${campos[i]} n√£o pode estar em branco. Latitude/Longitude, separar por ";" `);
          return;
        }
        if (campos[i] === "Tipo") {
          const tipoVal = (valor.toLowerCase());
    
              if (campos[i] === "Tipo") {
                const tipoVal = valor
                  .normalize("NFD")                // remove acentos
                  .replace(/[\u0300-\u036f]/g, "")
                  .toLowerCase();

                if (!tipoVal.includes("ponto") && !tipoVal.includes("poligono")) {
                  mostrarAlerta("Tipo deve conter 'ponto' ou 'pol√≠gono'.");
                  return;
                }
              }
        }
        if (campos[i] === "Ativo") {
          const ativoVal = valor.toLowerCase();
          if (ativoVal !== "true" && ativoVal !== "false") {
            mostrarAlerta("Ativo deve ser 'true' ou 'false'.");
            return;
          }

          cells[i].textContent = valor.toLocaleLowerCase();
          // Atualiza tabelaGeo com o valor j√° tratado
          if (!tabelaGeo[index]) tabelaGeo[index] = {};
              tabelaGeo[index][campos[i]] = valor.toLocaleLowerCase();
        }

        // Regras espec√≠ficas para pol√≠gono em Latitude/Longitude
        if (tipoAtual.search("poligono") >= 0 && ["Latitude","Longitude"].includes(campos[i])) {
          // Aceitar diversos tipos de ‚Äúpontos e v√≠rgulas‚Äù e normalizar espa√ßos

          const temSeparador = valor.search(separador) >=0; // ; normal ou fullwidth
          /*
          if (!temSeparador) {
            
            mostrarAlerta(`Erro: Para 'pol√≠gono', todos os valores em ${campos[i]} devem estar separados por [${separador}]. Exemplo: -20.322454; -20.322303 ; -20.322223.`);
            return;
          }
    */
          // Normaliza: m√∫ltiplos espa√ßos ‚âà 1 espa√ßo, troca todo ; por " - "
          valor = valor
            .replace(/\s+/g, " ")           // colapsa espa√ßos
            .replace(/[;Ôºõ]+/g, " - ");     // troca todas as varia√ß√µes de ; por " - "

          // Atualiza a c√©lula vis√≠vel imediatamente
          cells[i].textContent = valor;
        }

        // Atualiza tabelaGeo com o valor j√° tratado
        if (!tabelaGeo[index]) tabelaGeo[index] = {};
        tabelaGeo[index][campos[i]] = valor;
      }

      // Finaliza modo de edi√ß√£o
      for (let i = 0; i < cells.length - 2; i++) {
        cells[i].removeAttribute("contenteditable");
        cells[i].style.backgroundColor = "";
        cells[i].style.textAlign = "left";
      }

      // Restaura bot√£o
      const btnEditar = cells[cells.length - 1].querySelector("button");
      if (btnEditar) {
        btnEditar.innerText = "‚úèÔ∏è";
        btnEditar.onclick = function() { editarLinha(index); };
      }
    

      console.log("Linha salva:", tabelaGeo[index]);
    }

    // Helper para normalizar acentos (ex.: "pol√≠gono" -> "poligono")
    function removerAcentos(str) {
      return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    }

    // Fun√ß√£o para criar nova linha
    function criarLinha() {
      const tabelaBody = document.querySelector("#containerTabelaGeo tbody");

      // Objeto padr√£o para nova linha
      const novaLinha = {
        Tipo: "ZZZZZZZ (ponto) ou (pol√≠gono)",
        Equipamento: "",
        Ativo: "true",
        Protocolo: "",
        Azimute: "",
        Latitude: "",
        Longitude: ""
      };

      // Adiciona ao array global
      tabelaGeo.push(novaLinha);

      // Regera tabela completa
      const wrapper = document.querySelector(".table-wrapper");
      wrapper.innerHTML = gerarTabelaHTML(tabelaGeo);

      // Pega √≠ndice da √∫ltima linha
      const ultimoIndex = tabelaGeo.length - 1;

      // Habilita edi√ß√£o autom√°tica na √∫ltima linha
      editarLinha(ultimoIndex);

      // Faz scroll at√© a √∫ltima linha
      const tabela = document.querySelector("#containerTabelaGeo");
      const ultimaLinha = tabela.rows[ultimoIndex + 1]; // +1 porque cabe√ßalho √© linha 0
      ultimaLinha.scrollIntoView({ behavior: "smooth", block: "center" });
    }

    function limparBusca() {
      if (idDataTable) {
  // üëâ Resetar busca para garantir que todos os registros estejam vis√≠veis
        linhaReferencia = null;
        idDataTable.search("");
      }
    }
    // Fun√ß√£o para baixar CSV
    function baixarCSV() {
      // garante que n√£o h√° filtro aplicado
      limparBusca();

      let csv = "";

      // Cabe√ßalho
      csv += `Tipo,Equipamento,Ativo,Protocolo,Azimute,Latitude,Longitude\n`;

      // Linhas
      tabelaGeo.forEach(p => {
        const linha = [
          `${p.Tipo}`,
          `${p.Equipamento}`,
          `${p.Ativo}`,
          `${p.Protocolo}`,
          `${p.Azimute}`,
          `${p.Latitude}`,
          `${p.Longitude}`
        ].join(",");
        csv += linha + "\n";
      });

      const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = "tabelaGeorreferenciamento.csv";
      link.click();
    }

    function iniciarGeolocalizacao() {
      if (!navigator.geolocation) {
        desligarLocalizacao("Geolocaliza√ß√£o n√£o suportada");
        return;
      }

      watchId = navigator.geolocation.watchPosition(
        atualizarPosicao,
        tratarErroGeolocalizacao,
        {
          enableHighAccuracy: true,
          maximumAge: 5000,
          timeout: 10000
        }
      );
    }

    function atualizarTooltipBotao(lat, lon, acc, fonte) {
      const btn = document.getElementById("btnLocalizacao");
      btn.title = `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}, Precis√£o: ${acc}m, Fonte: ${fonte}`;
    }

    async function obterLocalizacao() {
      // Tenta GPS primeiro
      if (navigator.geolocation) {
        try {
          return await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(
              (pos) => {
                resolve({
                  lat: pos.coords.latitude,
                  lon: pos.coords.longitude,
                  acc: pos.coords.accuracy,
                  fonte: "GPS"
                });
              },
              (err) => reject(err),
              { enableHighAccuracy: true, timeout: 10000 }
            );
          });
        } catch (err) {
          console.warn("GPS indispon√≠vel:", err.message);
        }
      }

      // Fallback: IP
      try {
        const resp = await fetch("https://ipapi.co/json/", { mode: "cors" });
        const data = await resp.json();
        return {
          lat: data.latitude,
          lon: data.longitude,
          acc: 5000, // IP √© muito impreciso
          fonte: "IP"
        };
      } catch (err) {
        console.error("N√£o foi poss√≠vel obter localiza√ß√£o via IP:", err);
        return null;
      }
    }

    // Plota marcador no mapa
    function plotarUsuario(lat, lon, acc, fonte) {
        if (marcadorUsuario) mapa.removeLayer(marcadorUsuario);

        marcadorUsuario = L.marker([lat, lon], {
            icon: L.icon({
                iconUrl: 'icone-localizacao.png',
                iconSize: [35, 35]
            })
        }).addTo(mapa);

        marcadorUsuario.bindPopup(`Fonte: ${fonte}<br>Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}<br>Precis√£o: ${acc}m`).openPopup();
        mapa.setView([lat, lon], 16);
    }

    // Atualiza tooltip do bot√£o
    function atualizarTooltipBotao(lat, lon, acc, fonte) {
        const btn = document.querySelector('.botao-mapa');
        btn.title = `Fonte: ${fonte}\nLat: ${lat.toFixed(6)}\nLon: ${lon.toFixed(6)}\nPrecis√£o: ${acc}m`;
    }

    // Trata erros de geolocaliza√ß√£o
    function tratarErroGeolocalizacao(error) {
        let msg;
        switch(error.code) {
            case error.PERMISSION_DENIED:
                msg = "GPS indispon√≠vel: permiss√£o negada";
                break;
            case error.POSITION_UNAVAILABLE:
                msg = "GPS indispon√≠vel: posi√ß√£o n√£o dispon√≠vel";
                break;
            case error.TIMEOUT:
                msg = "GPS indispon√≠vel: timeout";
                break;
            default:
                msg = "GPS indispon√≠vel: erro desconhecido";
        }
        mostrarAlerta(msg);
    }

    function atualizarPosicao(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;
      const fonte = pos.fonte || "GPS";

      const btn = document.getElementById("toggleLocationBtn");

      // Tooltip DO BOT√ÉO
      btn.title =
        `Latitude: ${lat.toFixed(6)}\n` +
        `Longitude: ${lon.toFixed(6)}\n` +
        `Precis√£o: ${acc.toFixed(1)} m`;

      const coord = [lat, lon];

      // √çcone pr√≥prio
      const icon = L.divIcon({
        className: '',
        html: `
          <div style="
            width:18px;
            height:18px;
            background:#2563eb;
            border:3px solid white;
            border-radius:50%;
            box-shadow:0 0 8px rgba(37,99,235,.8);
          "></div>
        `,
        iconAnchor: [9, 9]
      });

      if (!markerLocalizacao) {
        markerLocalizacao = L.marker(coord, { icon }).addTo(map);
        map.setView(coord, 17);
      } else {
        markerLocalizacao.setLatLng(coord);
      }

      // C√≠rculo de precis√£o
      if (!circlePrecisao) {
        circlePrecisao = L.circle(coord, {
          radius: acc,
          color: "#2563eb",
          fillColor: "#93c5fd",
          fillOpacity: 0.25,
          weight: 2
        }).addTo(map);
      } else {
        circlePrecisao.setLatLng(coord);
        circlePrecisao.setRadius(acc);
      }
    }



    function desligarLocalizacao(motivo) {
      const btn = document.getElementById("toggleLocationBtn");

      trackingAtivo = false;

      if (watchId !== null) navigator.geolocation.clearWatch(watchId);
      watchId = null;

      if (markerLocalizacao) map.removeLayer(markerLocalizacao);
      if (circlePrecisao) map.removeLayer(circlePrecisao);

      markerLocalizacao = null;
      circlePrecisao = null;

      btn.style.background = "#f8fafc";
      btn.style.color = "#0f172a";
      btn.title = motivo || "Ativar geolocaliza√ß√£o";
}


    function atualizarTooltipBotao(lat, lon, acc, fonte) {
      const btn = document.getElementById("toggleLocationBtn");

      btn.title =
        `Fonte: ${fonte}\n` +
        `Latitude: ${lat.toFixed(6)}\n` +
        `Longitude: ${lon.toFixed(6)}\n` +
        `Precis√£o: ${acc.toFixed(0)} m`;
    }


    function atualizarPosicao(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const acc = pos.coords.accuracy;
      const fonte = pos.fonte || "GPS";

      const btn = document.getElementById("toggleLocationBtn");

      // Tooltip DO BOT√ÉO
      btn.title =
        `Latitude: ${lat.toFixed(6)}\n` +
        `Longitude: ${lon.toFixed(6)}\n` +
        `Precis√£o: ${acc.toFixed(1)} m`;

      const coord = [lat, lon];

      // √çcone pr√≥prio
      const icon = L.divIcon({
        className: '',
        html: `
          <div style="
            width:18px;
            height:18px;
            background:#2563eb;
            border:3px solid white;
            border-radius:50%;
            box-shadow:0 0 8px rgba(37,99,235,.8);
          "></div>
        `,
        iconAnchor: [9, 9]
      });

      if (!markerLocalizacao) {
        markerLocalizacao = L.marker(coord, { icon }).addTo(map);
        map.setView(coord, 17);
      } else {
        markerLocalizacao.setLatLng(coord);
      }

      // C√≠rculo de precis√£o
      if (!circlePrecisao) {
        circlePrecisao = L.circle(coord, {
          radius: acc,
          color: "#2563eb",
          fillColor: "#93c5fd",
          fillOpacity: 0.25,
          weight: 2
        }).addTo(map);
      } else {
        circlePrecisao.setLatLng(coord);
        circlePrecisao.setRadius(acc);
      }
    }


    function obterLocalizacaoMultiFonte() {
      if ("geolocation" in navigator) {
        watchId = navigator.geolocation.watchPosition(
          pos => {
            mostrarCoords(
              pos.coords.latitude,
              pos.coords.longitude,
              pos.coords.accuracy,
              "GPS / Navegador"
            );
          },
          err => {
            console.warn("GPS falhou, usando IP:", err.message);
            obterLocalizacaoPorIP();
          },
          {
            enableHighAccuracy: true,
            maximumAge: 5000,
            timeout: 10000
          }
        );
      } else {
        obterLocalizacaoPorIP();
      }
    }



    function mostrarCoords(lat, lon, acc, fonte) {
      mapaStatus.update(`
        üì° <b>Localiza√ß√£o ativa</b><br>
        <b>Lat:</b> ${lat.toFixed(6)}<br>
        <b>Lon:</b> ${lon.toFixed(6)}<br>
        <b>Precis√£o:</b> ${typeof acc === "number" ? acc.toFixed(1) + " m" : acc}<br>
        <span style="opacity:.7">Fonte: ${fonte}</span>
      `);
    }

  // Fun√ß√£o para plotar marcador no mapa com mais informa√ß√µes
    function plotarNoMapa(lat, lng, tipo, equipamento, azimute,index) {
      // Armazena a linha de refer√™ncia
      linhaReferencia = equipamento;
    
      if(!lat || !lng) return;

    
      lat = getPrimeiraOcorrencia(lat.toString());
      lng = getPrimeiraOcorrencia(lng.toString());

      
      L.circleMarker([lat, lng], {
        radius: 8,
        color: '#b71c1c',
        fillColor: '#e53935',
        fillOpacity: 0.9
      })
      .addTo(map)
      .bindPopup(`
                  <strong style="color: darkblue;">${tipo}</strong>
                  <ul style="padding-left: 15px; margin: 0;">
                    <li>${equipamento}</li>
                    <li>Latitude: ${lat}</li>
                    <li>Longitude: ${lng}</li>
                    ${azimute ? `<li>Azimute: ${azimute}</li>` : ""}
                  </ul>
                `)
      .openPopup();

      map.setView([lat, lng], 15);
        // ‚úÖ Fecha o painel lateral
      const painel = document.getElementById("painelTabela");
      painel.title = "Tabela Georreferenciamento"; // Texto do tooltip

      if (painel) {
        painel.style.display = "none";
      }
    }



      // Fun√ß√£o principal de geolocaliza√ß√£o
      function obterLocalizacaoUsuario() {
          if (!navigator.geolocation) {
              console.warn('Geolocaliza√ß√£o n√£o suportada neste navegador');
              return;
          }

          navigator.geolocation.getCurrentPosition(
              (pos) => {
                  const loc = {
                      lat: pos.coords.latitude,
                      lon: pos.coords.longitude,
                      acc: pos.coords.accuracy,
                      fonte: 'GPS'
                  };
                  plotarUsuario(loc.lat, loc.lon, loc.acc, loc.fonte);
                  atualizarTooltipBotao(loc.lat, loc.lon, loc.acc, loc.fonte);
              },
              (error) => {
                  console.warn('GPS indispon√≠vel: ' + error.message);
                  // Fallback: s√≥ centraliza no mapa sem GPS
                  map.setView([-15.7797, -47.9297], 6);
                  // opcional: mostrar mensagem ao usu√°rio
              },
              { enableHighAccuracy: true, timeout: 10000 }
          );
      }

      
      // === Helpers (no topo do arquivo) ===

      function clearAzimuteLayer() {
        azimuteLayer.clearLayers();
      }
      // Limpar todos os gr√°ficos de azimute no mapa
      function limparAzimuteOverlay() {
          azimuteLayer.clearLayers();
      }

      function clearMarkerClusters(mapInstance) {
          markersCluster.clearLayers();
      }

      function plotarConeAzimute(lat, lng, azimute, abertura = 40, alcance = 40) {
        const passos = 15;

        // Valida√ß√µes m√≠nimas (mantendo a ideia original de "n√£o plotar nada" em casos inv√°lidos)
      // üîë normaliza√ß√£o expl√≠cita
        const latNum = Number(lat);
        const lngNum = Number(lng);
        const azNum  = Number(azimute);

        if (
          !Number.isFinite(latNum) ||
          !Number.isFinite(lngNum) ||
          !Number.isFinite(azNum) ||
          azNum === 0
        ) {
          return L.layerGroup();
        }

        // Dist√¢ncia linear aproximada em graus (1¬∞ ~ 111.32 km na latitude m√©dia)
      const d = alcance / 111320;

      const pontos = [];
      for (let i = -abertura / 2; i <= abertura / 2; i += abertura / passos) {
        const ang = (azNum + i - 90) * Math.PI / 180;
        pontos.push([
          latNum + d * Math.sin(ang),
          lngNum + d * Math.cos(ang)
        ]);
      }

      pontos.unshift([latNum, lngNum]);

        // Retorna o pol√≠gono (cone) conforme seu estilo original
        return L.polygon(pontos, {
          color: 'blue',
          fillColor: 'blue',
          fillOpacity: 0.15,
          weight: 1
        });
      }

      function clearGraficosAzimute() {
        if (window.azimuteLayer) {
          window.azimuteLayer.clearLayers();
          return 'azimutes limpos';
        }
      }


      function inicializaMapa(tituloMapa) {
        if(isTracing) console.log('inicializaMapa');
          // Inicializa o mapa com OpenStreetMap
          
           map = L.map('map', {
            center: [-15.7938, -47.8825], // Marco Zero de Bras√≠lia
            zoom: 16,            // zoom inicial
            minZoom: 0,          // qu√£o longe pode afastar
            maxZoom: 21,         // limite m√°ximo permitido pelo mapa
            zoomControl: true,   // mostra o controle +/-
            zoomSnap: 0,         // permite zoom fracionado (0 = sem arredondar)
            zoomDelta: 0.25,     // passo do zoom ao usar controles/teclas
            wheelPxPerZoomLevel: 60, // rapidez do zoom pelo scroll
            scrollWheelZoom: true,   // ativa scroll do mouse
            doubleClickZoom: true,   // duplo clique d√° zoom
            touchZoom: true,         // pinch-zoom em touch
            zoomAnimation: true,     // anima√ß√£o de zoom
            markerZoomAnimation: true,
            layers: [baseMaps["OpenStreetMap"]]
          });




          map.setView([-15.7797, -47.9297], 6)
          /* Valores mais comuns de zoom
              üîπ Valores mais comuns
              Zoom	Descri√ß√£o
              0	Mundo inteiro
              5	Pa√≠s
              10	Cidade
              13	Bairro
              16	Quadras
              18	Rua
              20‚Äì22	Detalhe m√°ximo (depende do mapa)
          */
          ////////////////////////////////

          // === Layer exclusivo para azimutes ===
          window.azimuteLayer = L.layerGroup().addTo(map);
                    
          // 1) Remover o zoom que o Leaflet adiciona por padr√£o
          map.zoomControl.remove();

          // 2) Criar o controle de t√≠tulo (Topo Esquerda)
          var title = L.control({ position: 'topleft' });
          title.onAdd = function() {
              var div = L.DomUtil.create('div', 'custom-map-title');
              // Mantenha o mesmo conte√∫do que voc√™ j√° usa
            
              div.innerHTML = '<h2>'+tituloMapa+'</h2>';
              return div;
          };
          title.addTo(map);

          // 3) Adicionar  o controle de zoom no topo esquerdo,
          //    abaixo do t√≠tulo (carregado antes)
          L.control.zoom({ position: 'topleft' }).addTo(map);


          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {

            maxZoom: 18,        // n√≠veis m√°ximos suportados pela fonte
            minZoom: 0,
            tileSize: 256,      // 256 √© padr√£o; alguns usam 512 com 'zoomOffset'
            zoomOffset: 0,      // ajuste se usar 512px tiles
            detectRetina: true, // usa tiles retina quando dispon√≠veis
            attribution: '¬© Tiles'

          }).addTo(map);
          

    
  
          // Fun√ß√£o de clique no mapa
          function onMapClick(e) {
            if (!clickEnabled) return;

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            const centro = map.getCenter();
            const azimute = calcularAzimute(centro.lat, centro.lng, lat, lng);


           // Mostra popup s√≥ com texto (opcional)
            L.popup()
              .setLatLng([lat, lng])
              .setContent(`
                <b>Coordenadas:</b><br>
                Latitude: ${lat.toFixed(6)}<br>
                Longitude: ${lng.toFixed(6)}<br>
                Azimute em rela√ß√£o ao norte: ${azimute.toFixed(2)}¬∞
              `)
              .openOn(map);
            // üëâ bot√£o para copiar
            const btnCopiar = document.createElement("button");
            btnCopiar.textContent = "üìã Copiar coordenadas";
            btnCopiar.style.cssText = "margin-top:8px; padding:4px 8px; cursor:pointer;";
            btnCopiar.onclick = () => {
              const texto = `${lat.toFixed(6)} \t ${lng.toFixed(6)}`;
              navigator.clipboard.writeText(texto).then(() => {
                btnCopiar.textContent = "‚úÖ Copiado!";
                setTimeout(() => btnCopiar.textContent = "üìã Copiar coordenadas", 1500);
              });
            };
            container.appendChild(btnCopiar);

            L.popup()
              .setLatLng(e.latlng)
              .setContent(container)
              .openOn(map);
          }

        /*
‚úÖ OP√á√ÉO 3 ‚Äî Camadas / overlays
<i class="fa-solid fa-layer-group" style="color:darkblue;"></i>


üîπ Ideal se a fun√ß√£o for ligar/desligar visualiza√ß√µes

‚úÖ OP√á√ÉO 4 ‚Äî Desenho / geometria
<i class="fa-solid fa-draw-polygon" style="color:darkblue;"></i>


üîπ Perfeito para pol√≠gonos, √°reas, recintos

‚úÖ OP√á√ÉO 5 ‚Äî Radar / dire√ß√£o (se envolve azimute)
<i class="fa-solid fa-compass" style="color:darkblue;"></i>


üîπ Excelente se o bot√£o ativa cones de azimute

üîß SUBSTITUI√á√ÉO DIRETA NO SEU C√ìDIGO
üîÅ TROQUE APENAS ESTA LINHA:
container.innerHTML = '<i class="fa-solid fa-chart-line" style="color:darkblue;"></i>';

‚úÖ POR (exemplo recomendado):
container.innerHTML = '<i class="fa-solid fa-map-location-dot" style="color:darkblue;"></i>';

üé® PEQUENA MELHORIA VISUAL (OPCIONAL)

Se quiser dar mais ‚Äúcara de bot√£o Leaflet‚Äù:

container.style.borderRadius = "4px";
container.style.boxShadow = "0 1px 4px rgba(0,0,0,0.3)";

üß† RECOMENDA√á√ÉO FINAL

Se a fun√ß√£o:

plota pontos, √°reas e cones ‚Üí fa-map-location-dot

plota pol√≠gonos/recintos ‚Üí fa-draw-polygon

liga/desliga camadas ‚Üí fa-layer-group

envolve azimute/dire√ß√£o ‚Üí fa-compass

Se quiser, me diga exatamente o que o bot√£o faz (plotar tudo, toggle, azimute, √°rea, etc.) que eu te indico o melhor √≠cone poss√≠vel üëç

        */

          const TogglePlotControl = L.Control.extend({
              options: { position: "topright" },

              onAdd: function () {
                  const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

                  container.innerHTML = '<i class="fa-solid fa-location-dot" style="color:darkblue;"></i>';
                  container.style.backgroundColor = "white";
                  container.style.cursor = "pointer";
                  container.style.fontSize = "18px";
                  container.style.textAlign = "center";
                  container.style.lineHeight = "27px";
                  container.style.width = "20px";
                  container.style.height = "27px";

                  let nextAction = "clear";
                  L.DomEvent.disableClickPropagation(container);

                  container.onclick = function () {
                      try {
                          if (nextAction === "clear") {
                              clearMarkerClusters(map);
                              limparAzimuteOverlay();
                              container.style.backgroundColor = "white";
                              nextAction = "plot";
                          } else {
                              plotarTabelaGeorreferencimento(tabelaGeo, map);
                              container.style.backgroundColor = "#cce5ff";
                              nextAction = "clear";
                          }
                      } catch (err) {
                          console.error("Erro no TogglePlotControl:", err);
                      }
                  };

                  return container;
              }
          });

          map.addControl(new TogglePlotControl());



          // Controle personalizado click no mapa para as coordenadas
          const ToggleCoordsControl = L.Control.extend({
            options: { position: "topright" },

            onAdd: function () {
              const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

              // √çcone FontAwesome (ex.: localiza√ß√£o cruzada)
              
              container.innerHTML = '<i class="fa-solid fa-crosshairs" style="color:darkblue;"></i>';              
              container.style.backgroundColor = "white";
              container.style.cursor = "pointer";
              container.style.fontSize = "18px";
              container.style.textAlign = "center";
              container.style.lineHeight = "27px";
              container.style.width = "20px";
              container.style.height = "27px";

              container.onclick = function () {
                if (clickEnabled) {
                  map.off("click", onMapClick);
                  clickEnabled = false;
                  container.style.backgroundColor = "white"; // desligado
                } else {
                  map.on("click", onMapClick);
                  clickEnabled = true;
                  container.style.backgroundColor = "#cce5ff"; // ligado
                }
              };

              return container;
            }
          });

          // Adicionar controle ao mapa
          map.addControl(new ToggleCoordsControl());

          // cria controle de upload dentro do mapa
          const UploadControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function () {
              // bot√£o estilizado
              const btn = L.DomUtil.create(
                "button",
                "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
              );

  

              btn.innerHTML = `
                <label for="fileCSV" title="Upload de arquivo CSV" style="cursor:pointer;">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="25"
                      viewBox="0 0 24 24" style="display:block;color:#0D47A1">
                    <path fill="currentColor" d="
                      M12 5
                      L5 12
                      H9
                      V19
                      H15
                      V12
                      H19
                      Z
                    "/>
                  </svg>
                </label>
                <input type="file" id="fileCSV" accept=".csv,text/csv">
              `;


              // evita arrastar o mapa ao clicar
              L.DomEvent.disableClickPropagation(btn);



              // efeito de clique (pressionado)

              btn.onmousedown = function () {
                btn.style.boxShadow = "none";
                btn.style.transform = "translateY(2px)";
              };
              btn.onmouseup = function () {
                btn.style.boxShadow = "none";
                btn.style.transform = "translateY(0)";
              };

              // refer√™ncias
              const inputFile = btn.querySelector("#fileCSV");
              const labelFile = btn.querySelector('label[for="fileCSV"]'); // <‚Äî seletor correto

              // guardas
              if (!inputFile || !labelFile) {
                console.error('UploadControl: input ou label n√£o encontrado.');
                return btn;
              }

              // a√ß√£o ao selecionar arquivo
              inputFile.addEventListener("change", function (event) {
                const file = event.target.files[0];
                if (file) {
                  // processarCSV(file);
                }
              });

              // (garantia extra) bloqueia click no input quando desabilitado
              inputFile.addEventListener("click", (ev) => {
                if (inputFile.disabled) {
                  ev.preventDefault();
                  ev.stopPropagation();
                }
              });

              // (garantia extra) bloqueia click no label quando desabilitado
              labelFile.addEventListener("click", (ev) => {
                if (inputFile.disabled) {
                  ev.preventDefault();
                  ev.stopPropagation();
                }
              });

              // tooltips (opcional)
              const TOOLTIP_ENABLED  = 'Upload de arquivo CSV';
              const TOOLTIP_DISABLED = 'Upload desabilitado: j√° h√° dados carregados';



              // estado inicial ‚Äî sem alterar estilos do bot√£o nem do label
              function disableUpload() {
                inputFile.disabled = true;
                labelFile.title = TOOLTIP_DISABLED;
              }
              function enableUpload() {
                inputFile.disabled = false;
                labelFile.title = TOOLTIP_ENABLED;
              }

              // aplica estado inicial
              if (isDataInStorage()) {
                disableUpload();
              } else {
                enableUpload();
              }

              

              return btn;
            }
          });

          map.addControl(new UploadControl());

          // evento de upload
          document.getElementById("fileCSV").addEventListener("change", (event) => {
            const arquivo = event.target.files[0];
            if (!arquivo) return;

            const reader = new FileReader();
            reader.onload = () => {
              tabelaGeo = csvParaJson(reader.result);

              //settabelaGeo(tabelaGeo);
              event.target.value = ""; // limpa para permitir re-sele√ß√£o
            };
            reader.readAsText(arquivo);
          });


      // --- Controle de Cursores Leaflet ---

// --- Controle de Cursores Leaflet ---
var CursorMenu = L.Control.extend({
  options: { position: 'topright' },

  onAdd: function (map) {
    // Container do controle (UM bot√£o s√≥)
    const container = L.DomUtil.create(
      "div",
      "leaflet-bar leaflet-control leaflet-control-custom cursor-menu-container"
    );

    // √çcone no pr√≥prio container (ajuste 'fa' para 'fas' ou 'fa-solid' conforme sua vers√£o do FA)
    container.innerHTML = '<i class="fa fa-mouse-pointer" style="color:darkblue;"></i>';

    // Apar√™ncia id√™ntica ao ToggleCoordsControl
    container.style.backgroundColor = "white";
    container.style.cursor = "pointer";
    container.style.fontSize = "18px";
    container.style.textAlign = "center";
    container.style.lineHeight = "27px";
    container.style.width = "20px";
    container.style.height = "27px";
    container.style.position = "relative"; // base para o dropdown

    // Evita propaga√ß√£o para o mapa
    L.DomEvent.disableClickPropagation(container);
    L.DomEvent.disableScrollPropagation(container);

    // Menu de op√ß√µes (HORIZONTAL)
    const optionsDiv = L.DomUtil.create("div", "cursor-options", container);
    optionsDiv.style.display = "none";
    optionsDiv.style.position = "absolute";
    optionsDiv.style.top = "30px";    // logo abaixo do bot√£o
    optionsDiv.style.right = "40px";     // alinhado √† direita do bot√£o
    optionsDiv.style.backgroundColor = "white";
    optionsDiv.style.border = "1px solid #ccc";
    optionsDiv.style.zIndex = "1000";
    optionsDiv.style.boxShadow = "0 1px 3px rgba(0,0,0,0.2)";
    optionsDiv.style.flexDirection = "row";   // horizontal
    optionsDiv.style.alignItems = "stretch";
    optionsDiv.style.whiteSpace = "nowrap";
    optionsDiv.style.padding = "0";

    // Op√ß√µes de cursor
    // Se estiver com FA5, troque 'fa' (ou 'fa-solid') por 'fas' aqui tamb√©m.
    const cursors = [
      ['fa fa-hand-paper', 'grab', 'Navega√ß√£o (M√£o Aberta)'],
      ['fa fa-hand-pointer', 'pointer', 'Sele√ß√£o (M√£o com Dedo)'],
      ['fa fa-crosshairs', 'crosshair', 'Precis√£o/Desenho (Mira)'],
      ['fa fa-arrow-up-right-from-square', 'default', 'Padr√£o Sistema']
    ];

    cursors.forEach(function (c, idx) {
      const optBtn = L.DomUtil.create("div", "cursor-btn", optionsDiv);
      optBtn.innerHTML = `<i class="${c[0]}"></i>`;
      optBtn.title = c[2];

      // Estilo dos itens na horizontal
      optBtn.style.display = "inline-flex";
      optBtn.style.alignItems = "center";
      optBtn.style.gap = "8px";
      optBtn.style.padding = "6px 10px";
      optBtn.style.cursor = "pointer";
      optBtn.style.userSelect = "none";
      optBtn.style.background = "white";

      // Divisor vertical entre itens
      if (idx < cursors.length - 1) {
        optBtn.style.borderRight = "1px solid #e0e0e0";
      }

      optBtn.onmouseenter = function () {
        optBtn.style.background = "#f2f2f2";
      };
      optBtn.onmouseleave = function () {
        optBtn.style.background = "white";
      };
      optBtn.onclick = function (e) {
        e.stopPropagation();
        map.getContainer().style.cursor = c[1];
        optionsDiv.style.display = "none";
      };
    });

    // Toggle do dropdown no PR√ìPRIO container (UM bot√£o)
    L.DomEvent.on(container, "click", function (e) {
      L.DomEvent.stop(e);
      optionsDiv.style.display =
        optionsDiv.style.display === "flex" ? "none" : "flex";
    });

    // Fecha ao clicar fora
    document.addEventListener("click", function onDocClick(ev) {
      if (!container.contains(ev.target)) optionsDiv.style.display = "none";
    });

    return container;
  }
});

        map.addControl(new CursorMenu());

          //Popup seletor de tipo de mapa. Aparece no canto superior direito
          const MapSelector = L.Control.extend({
            options: { position: "topright" },
            onAdd: function () {
              // cria bot√£o com estilo .btn-acao e .btn-fechar
              const container = L.DomUtil.create(
                "button",
                "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
              );
              container.title = "Selecionar tipo de mapa";
              container.innerHTML = `
                <img src="https://cdn-icons-png.flaticon.com/512/854/854878.png" 
                    alt="Salvar csv" style="width:20px;height:20px;">
              `;

              // efeito ao clicar (pressionado)
              container.onmousedown = function () {
                container.style.boxShadow = "0 2px #0D47A1";
                container.style.transform = "translateY(2px)";
              };
              container.onmouseup = function () {
                container.style.boxShadow = "0 4px #0D47A1";
                container.style.transform = "translateY(0)";
              };

              // evita arrastar o mapa ao clicar no controle
              L.DomEvent.disableClickPropagation(container);

              // vari√°veis de controle do popup
              let popupAberto = false;
              let popupRef = null;

              // a√ß√£o ao clicar no bot√£o
              container.onclick = function () {
                if (!popupAberto) {
                  let html = "<b>Selecione o mapa:</b><br>";
                  Object.keys(baseMaps).forEach(nome => {
                    const icon = baseMapIcons[nome] || "üó∫Ô∏è"; // fallback
                    html += `<div style="cursor:pointer; margin:3px; color:blue;" 
                              onclick="window.setBaseMap('${nome}')">${icon} ${nome}</div>`;
                  });
                  popupRef = L.popup({ maxWidth: 300 })
                    .setLatLng(map.getCenter())
                    .setContent(html)
                    .openOn(map);
                  popupAberto = true;
                } else {
                  map.closePopup(popupRef);
                  popupAberto = false;
                }
              };

              return container;
            }
          });

          map.addControl(new MapSelector());
          
          // Fun√ß√£o global para trocar mapa base
          window.setBaseMap = function (nome) {
            map.eachLayer(layer => {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            baseMaps[nome].addTo(map);
          };
         
          const ¬†precisaoAgrupamentoMinimo = 50;
          const ¬†precisaoAgrupamentoMaximo = 150;

        // Controle Leaflet para abrir/fechar painel
        L.Control.Excel = L.Control.extend({
            onAdd: function(map) {
              const btn = L.DomUtil.create(
                "button",
                "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
              );

              btn.innerHTML = `
                <img src="https://cdn-icons-png.flaticon.com/512/2535/2535554.png" 
                    alt="Coordenadas" style="width:20px;height:20px;">
              `;
              btn.title = "Apresenta/oculta tabela georreferenciamento";

              L.DomEvent.disableClickPropagation(btn);

              btn.onmousedown = function () {
                btn.style.boxShadow = "0 2px #0D47A1";
                btn.style.transform = "translateY(2px)";
              };
              btn.onmouseup = function () {
                btn.style.boxShadow = "0 4px #0D47A1";
                btn.style.transform = "translateY(0)";
              };

              btn.onclick = function() {
                const painel = document.getElementById("painelTabela");
                const wrapper = painel.querySelector(".table-wrapper");
                const displayAtual = window.getComputedStyle(painel).display;

                if (displayAtual === "none") {
                  // üëâ abrir painel
                  if (!tabelaGeo || tabelaGeo.length === 0 || (tabelaGeo.length > 0 && !tabelaGeo[0].Tipo)) {
                  
                    // se tabelaGeo estiver vazio, chama diretamente a fun√ß√£o de upload
                    mostrarAlerta('Fa√ßa Upload do arquivo com as coordenadas.')
              
                    return; // n√£o abre painel vazio
                  }

                  const htmlTabela = gerarTabelaHTML(tabelaGeo);
                  wrapper.innerHTML = htmlTabela;
                  painel.style.display = "block";

                  setTimeout(() => {
                    const tabelaEl = document.querySelector("#containerTabelaGeo"); // pega a TAG <table>

                    if (!tabelaEl) return;

                    if (idDataTable) idDataTable.destroy();  
                    painel.style.display = "block";             
                    idDataTable = new DataTable(tabelaEl, {
                      searchable: true,
                      sortable: true,
                      perPage: 10, // n√∫mero inicial de registros por p√°gina
                      perPageSelect: [10,15, 30, 50, 100], // op√ß√µes que aparecem no seletor

                      fixedHeight: false, // for√ßa respeitar o perPage
                      labels: {
                        placeholder: "üîç Buscar...",
                        perPage: "{select} registros por p√°gina",
                        noRows: "Nenhum registro encontrado",
                        info: "Mostrando {start} at√© {end} de {rows} registros"
                      }
                    });
      
                    if (linhaReferencia) {
                      idDataTable.search(linhaReferencia);
                    }
                  }, 250);

                } else {
                  painel.style.display = "none";
                }
              };

              return btn;
            },
            onRemove: function(map) {}
          });

          map.addControl(new L.Control.Excel({ position: 'topright' }));


          // Grupo de clusters (configurando para n√£o estourar o mapa ao clicar)
          markersCluster = L.markerClusterGroup({
            // Comportamento de clique
            zoomToBoundsOnClick: true,     // üö´ n√£o dar zoom ao clicar no cluster
            spiderfyOnClick: true,          // üï∑Ô∏è abrir os marcadores em ‚Äúaranha‚Äù ao clicar
            spiderfyOnEveryZoom: false,     // n√£o manter aranha em cada zoom
            showCoverageOnHover: false,     // n√£o mostrar pol√≠gono de cobertura ao hover

            // Agrupamento e desempenho
            removeOutsideVisibleBounds: false,
            animateAddingMarkers: false,    // desempenho; evita anima√ß√£o ao adicionar
            disableClusteringAtZoom: 16,  // ou um n√∫mero (ex.: 16) se quiser desagrupar em zoom alto

            // Raio de cluster: quanto menor, menos marcadores entram no mesmo cluster
            // Ajuste conforme a densidade e seu range de zoom
            
            maxClusterRadius: function (zoom) {
              // diminui o raio em zooms altos (menos cluster; mais pontos diretos)
              return zoom >= 14 ? 30 : zoom >= 10 ? 40 : 60;
            },

            // Se quiser abrir um pouco mais os pontos quando spiderfying:
            spiderfyDistanceMultiplier: 1.2 // opcional; abre mais espa√ßo entre marcadores
          });
          map.on("click", onMapClick);

      }


      // Fun√ß√£o que converte CSV em JSON
      function csvParaJson(csvTexto) {
      
        const linhas = csvTexto.trim().split("\n");
        const cabecalhos = linhas[0].split(separador).map(h => h.trim());

        return linhas.slice(1).map(linha => {
          const valores = linha.split(separador).map(v => v.trim());
          const objeto = {};
          cabecalhos.forEach((chave, i) => {
            objeto[chave] = valores[i].replace('"','').replace('"','').replace('"','').replace('"','')
          });
          return objeto;
        });
      }

      function lerCSV(arquivo) {
        if(isTracing) console.log('lerCSV')       
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => {
            try {
              const json = csvParaJson(reader.result);
              tabelaGeo = json;
              resolve(json);
            } catch (e) { 
            
              reject(e); }
          };
          reader.onerror = () => {
            

            reject("Erro ao ler arquivo");}
          reader.readAsText(arquivo);
        });
      }

      document.getElementById("fileCSV").addEventListener("change", async (event) => {
          if(isTracing) console.log('getElementById');
          const arquivo = event.target.files[0];
          if (!arquivo) return;
        
          await lerCSV(arquivo);

          plotarTabelaGeorreferencimento(tabelaGeo,map)
      });

      function getArrayIcones() {
        let arrayIcones = [
                            {tipo: "Recinto (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/128/684/684908.png" },
                            {tipo: "Balan√ßa (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/512/8248/8248483.png" },
                            {tipo: "Catraca e similares (ponto)", url: "torniquetes.png",icone:"https://cdn-icons-png.flaticon.com/512/3205/3205227.png" },
                            {tipo: "C√¢mera (ponto)", url: "camera-ctv.png",icone: "https://cdn-icons-png.flaticon.com/512/5388/5388847.png"},
                            {tipo: "Port√£o, gate e similares (ponto)", url: "boom_gate2.png",icone:"https://cdn-icons-png.flaticon.com/512/16867/16867628.png" },
                            {tipo: "Port√™iner (ponto)", url: "portainer.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                            
                            {tipo: "Recinto (pol√≠gono)", url: "area.png",icone: "https://cdn-icons-png.flaticon.com/512/12355/12355988.png"},
                            {tipo: "Scanner (ponto)", url:  "barcode-scanner_2605593.png",icone: "https://cdn-icons-png.flaticon.com/512/4482/4482023.png"},
                            {tipo: "√Årea de armazenamento de lotes (pol√≠gono)", url: "icons8-armaz√©m-80.png",icone:"https://cdn-icons-png.flaticon.com/512/754/754877.png" },
                            {tipo: "√Årea de confer√™ncia f√≠sica (pol√≠gono)", url: "peso.png",icone: "https://cdn-icons-png.flaticon.com/512/16355/16355158.png"},
                            {tipo: "√Årea de posicionamento de cont√™ineres (pol√≠gono)", url: "Container_Red_icon-icons.com_54903.png",icone:"https://cdn-icons-png.flaticon.com/512/1254/1254256.png" },
                            {tipo: "√Årea de posicionamento de ve√≠culos (pol√≠gono)", url: "caminh√£o.png",icone: "https://cdn-icons-png.flaticon.com/512/8397/8397505.png"},                               
                            {tipo: "Tanque de armazenamento (ponto)", url: "TanqueArmazenamento.jpg",icone: "https://cdn-icons-png.flaticon.com/512/5755/5755651.png"},
                            {tipo: "Silo (ponto)", url: "silo.png",icone: "https://cdn-icons-png.flaticon.com/512/2078/2078261.png"},
                            {tipo: "√Årea de controle de carga solta (pol√≠gono)", url: "cargaSolta.png",icone: "https://cdn-icons-png.flaticon.com/512/4829/4829649.png"},
                            {tipo: "Port√™iner Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                            {tipo: "Port√™iner, Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},

                            //{tipo: "", url: ".png"},
                              //{tipo: "", url: ".png"},                                                                                                

                          ]
        return arrayIcones                  
      }

      function getIcone(icone,azimute) {

          let arrayIcones = getArrayIcones();
          let retorno = 'https://cdn-icons-png.flaticon.com/512/7199/7199765.png';
          
          for (let i = 0; i < arrayIcones.length; i++) {
          
            if (arrayIcones[i].tipo === icone) {
                retorno = arrayIcones[i].icone
                
                break;
            }           
          }
          //Se for c√¢mera e n√£o h√° azimute, entendemos ser c√¢mera dome
          //Retornar endere√ßo do √≠cone de uma dome  
          if(icone.search('C√¢mera')>=0 && !azimute)
              retorno = 'https://cdn-icons-png.flaticon.com/512/10005/10005664.png';
          return retorno;   
      }

      function getPrimeiraOcorrencia(coord) {

          if(!coord) return 0.;
          let vetor = coord.toString().split( ' - ')


          return vetor[0]

      }
      // Fun√ß√£o que desenha gr√°fico de azimute em canvas

  
    // Fun√ß√£o para calcular azimute em rela√ß√£o ao norte verdadeiro
      function calcularAzimute(lat1, lon1, lat2, lon2) {
        // Converter graus para radianos
        const toRad = deg => deg * Math.PI / 180;
        const toDeg = rad => rad * 180 / Math.PI;

        const dLon = toRad(lon2 - lon1);
        const lat1Rad = toRad(lat1);
        const lat2Rad = toRad(lat2);

        // F√≥rmula de azimute (bearing)
        let y = Math.sin(dLon) * Math.cos(lat2Rad);
        let x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

        let brng = toDeg(Math.atan2(y, x));
        return (brng + 360) % 360; // normalizar para 0‚Äì360¬∞
      }

      // Fun√ß√£o que calcula o cone e retorna o array de coordenadas
      function calcularCone(lat, lon, azimute, abertura, altura) {
        var rad = azimute * Math.PI / 180;
        var half = abertura / 2 * Math.PI / 180;

        var lat1 = lat + altura * Math.cos(rad - half);
        var lon1 = lon + altura * Math.sin(rad - half);

        var lat2 = lat + altura * Math.cos(rad + half);
        var lon2 = lon + altura * Math.sin(rad + half);

        // retorna o array de tabelaGeo do tri√¢ngulo
        return [[lat, lon], [lat1, lon1], [lat2, lon2]];
      }
      
      function getCoordenada(coordenada) {
            
        if(typeof coordenada === 'string') coordenada = parseFloat(coordenada)
        return coordenada;
      }

      function contarRecintos(tabelaGeo) {
          let contador = 0;
          for (let ix = 0; ix < tabelaGeo.length; ix++) {
            if (tabelaGeo[ix].Tipo && tabelaGeo[ix].Tipo.search('Recinto') !== -1) {
              contador++;
            }
          }
          return contador;
      }

      function settabelaGeo(tabelaGeo){
          tabelaGeo = tabelaGeo;
      }  

      function plotarTabelaGeorreferencimento(tabelaGeo,mapInstance = map) {
        if(isTracing) console.log('plotarTabelaGeorreferencimento',tabelaGeo);

         clearMarkerClusters(mapInstance);
         limparAzimuteOverlay();
        // Grupo que receber√° polilinha, pol√≠gonos e marcadores do seu desenho
        //const desenhoLayerGroup = L.featureGroup([], { meuIdentificadorDeCluster: true }).addTo(mapInstance);

        
        if (!mapInstance) {
          console.error('Map n√£o inicializado');
          return;
        }

  
          // √çcones da web
          arrayIcones = []

  
          //Conta quantos Recintos h√° em tabelaGeo
        
            let qtdRecintos = contarRecintos(tabelaGeo); 
          /*
            //Tenta ler da storage
          if(qtdRecintos == 0) { 
              let retorno = lerDoStorage('ploter')
              if(retorno)
              tabelaGeo = retorno 

          }
          */

                          
          //Percorre a tabela de ativos                          
          for (let ix = 0; ix < tabelaGeo.length; ix++) {  
     
            let p = tabelaGeo[ix]

            if(p.Ativo != 'true') continue

            //Validar se √© ponto ou √°rea
            //Ponto n√£o pode ter pol√≠gono no p.Tipo
            let iconURL = getIcone(p.Tipo,p.Azimute)

            const customIcon = L.icon({
              iconUrl: iconURL,
              iconSize: [32, 32],
              iconAnchor: [16, 32],
              popupAnchor: [0, -32]
              });
                
            latitude  = ''
            longitude = ''

            if(p.Tipo.search('pol√≠gono') >=0) {
        

                let arrayLatitude = p.Latitude.split(' - ')
                let arrayLongitude = p.Longitude.split(' - ')

                let ultimaLatitude  = getCoordenada(arrayLatitude[0]); 
             
                let UltimaLongitude = getCoordenada(arrayLongitude[0]) ;      
                  
                for (let lx = 0; lx < arrayLatitude.length; lx++) {  
                    if(!arrayLatitude[lx] || ! arrayLongitude[lx]) continue

                    if (p.Tipo.search('Recinto')>=0) { 
                        poligonoRecinto.push([parseFloat(getCoordenada(arrayLatitude[lx]) ), parseFloat(getCoordenada(arrayLongitude[lx]))]);
                        //Para fechar o pol√≠gono
                        if(lx + 1 === arrayLatitude.length) {
                          poligonoRecinto.push([ultimaLatitude, UltimaLongitude]);
                        }
                    } else {

                      areas.forEach(area => {
                      
                          if (p.Tipo.toLocaleLowerCase().search(area.titulo.toLocaleLowerCase()) >= 0) {
                            area.coords.push([parseFloat(getCoordenada(arrayLatitude[lx])) , parseFloat(getCoordenada(arrayLongitude[lx]))]);
                          }
                    });  
                  }

                }

            } 
            if(p.Tipo.search('ponto') >=0) {
                if(p.Latitude === '') continue; 
              
                latitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)));
                longitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)));

                const itemGroup = L.layerGroup()
               
                let azimute = p.Azimute ? p.Azimute : 0.

                //Marco Zero - Recinto
                if(qtdRecintos===1) {
                    // Define o t√≠tulo da p√°gina
                   // document.getElementById("map-title").innerHTML = p.Equipamento; 
                }
                if(p.Tipo.search('Recinto')>=0) {
                  
                  //var markers = L.markerClusterGroup();
                  /*
                  var markers = L.markerClusterGroup();
                  markers.addLayer(L.marker([latitude, longitude]).//bindPopup(p.Equipamento));
                  bindPopup("<strong style='color:blue;'>" + p.Equipamento + "</strong>"));

                  mapInstance.addLayer(markers);
                  continue;
                  */
                  const itemGroup = L.layerGroup();

                  const marker = L.marker([latitude, longitude])
                    .bindPopup("<strong style='color:blue;'>" + p.Equipamento + "</strong>");

                  itemGroup.addLayer(marker);
                  markersCluster.addLayer(itemGroup);
                  continue;                 

                }   
                //Se for c√¢mera e houver azimute
                //if(p.Tipo.search('C√¢mera') >=0 && p.Azimute ){
                const latNum = Number(latitude);
                const lngNum = Number(longitude);
                const azNum  = Number(p.Azimute);

                if (
                  p.Tipo.search('C√¢mera') >= 0 &&
                  Number.isFinite(latNum) &&
                  Number.isFinite(lngNum) &&
                  Number.isFinite(azNum)
                ) {
                    // Usa a fun√ß√£o para obter coordenadas e desenhar no mapa
                      var coordsCone = calcularCone(latitude, longitude, azimute, 40, 0.0005);
                      /*
                  Op√ß√µes principais
                  color: cor da borda.
                  weight: espessura da borda.
                  dashArray: define se a linha √© cont√≠nua ou tracejada. Exemplo: "10, 5" (10px tra√ßo, 5px espa√ßo).
                  fillColor: cor interna do pol√≠gono.
                  fillOpacity: opacidade do preenchimento (0 = transparente, 1 = opaco).
                  opacity: opacidade da linha de contorno.
                      */
                     /*
                  L.polygon(coordsCone, {
                    color: 'blue',        // cor da linha
                    weight: 1,            // espessura da linha
                    dashArray: '5, 5',    // tra√ßos e espa√ßos (5px tra√ßo, 5px espa√ßo)
                    fillColor: 'blue',    // cor de preenchimento
                    fillOpacity: 0.09      // opacidade do preenchimento
                  }).addTo(mapInstance);
                  */
                    const cone = plotarConeAzimute(latitude, longitude, azimute);
                    itemGroup.addLayer(cone);



                }
                // Marker com popup contendo texto + gr√°fico
                
                let marker = L.marker([latitude, longitude], { icon: customIcon })
                  .bindPopup(() => {
                    // conte√∫do textual
                    const div = document.createElement("div");
                    
                    div.innerHTML = `
                      <strong style="color: blue;">${p.Tipo}</strong>
                        <ul style="padding-left: 15px; margin: 0;">
                          <li>${p.Equipamento}</li>
                          <li>Latitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)))}</li>
                          <li>Longitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)))}</li>

                          ${p.Azimute ? `<li>Azimute: ${p.Azimute}</li>` : ""}
                        </ul>
                    
                    `;
                    /* üìå O cone j√° foi criado junto com o marker, n√£o precisa duplicar.
                    marker
                      .on('popupopen', () => {
                        if (p.Azimute) {
                          window.azimuteLayer.clearLayers();
                          const cone = plotarConeAzimute(latitude, longitude, p.Azimute);
                          window.azimuteLayer.addLayer(cone);
                        }
                      })
                      .on('popupclose', () => {
                        window.azimuteLayer.clearLayers();
                      });
                      */
                    if (p.Azimute) {
                      div.insertAdjacentHTML(
                        "beforeend",
                        `<div style="margin-top:6px;font-size:12px;color:#444">
                          Azimute: <b>${p.Azimute}¬∞</b>
                        </div>`
                      );
                    }
                    return div;
                  });

                // markersCluster.addLayer(marker);
                itemGroup.addLayer(marker);
                markersCluster.addLayer(itemGroup);
              
              }
          }
            


          if(markersCluster) mapInstance.addLayer(markersCluster);

          const marcadorVermelho = L.icon({
            iconUrl: 'https://cdn-icons-png.flaticon.com/128/1397/1397898.png',
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          });

          // Adiciona marcador na primeira coordenada
          const recintoGroup = L.layerGroup();
          if(poligonoRecinto.length >0) {  
                const primeiraCoord = poligonoRecinto[0]; // pega o primeiro ponto
                /*
                  // Pol√≠gono do Recinto
                  L.polyline(poligonoRecinto, {
                    color: infoArea[1].cor,
                    weight: 4,
                    opacity: 0.8
                  }).addTo(desenhoLayerGroup)
                    .bindTooltip("<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' style='vertical-align:middle;margin-right:5px;'/>" +
                                    "<strong style='color:darkred;'>Pol√≠gono do Recinto</strong>",
                    {
                      permanent: false,
                      direction: "center",
                      className: "tooltip-transparent"
                    });
                  L.marker(primeiraCoord, { icon: marcadorVermelho })
                    .addTo(desenhoLayerGroup)
                    .bindPopup(
                      "<strong style='color:darkred;'>Marco 0 do Recinto</strong>",
                      { className: 'popup-transparente' }
                    );
*/


              // Pol√≠gono do Recinto
              const poligonoLayer = L.polyline(poligonoRecinto, {
                        color: infoArea[1].cor,
                        weight: 4,
                        opacity: 0.8
                      }).bindTooltip(
                        "<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' " +
                        "style='vertical-align:middle;margin-right:5px;'/>" +
                        "<strong style='color:darkred;'>Pol√≠gono do Recinto</strong>",
                        {
                          permanent: false,
                          direction: "center",
                          className: "tooltip-transparent"
                        }
                      );

                      // Marco Zero do Recinto
                      const marcoZeroMarker = L.marker(primeiraCoord, { icon: marcadorVermelho })
                        .bindPopup(
                          "<strong style='color:darkred;'>Marco 0 do Recinto</strong>",
                          { className: 'popup-transparente' }
                        );

                      // Adiciona tudo ao grupo
                      recintoGroup.addLayer(poligonoLayer);
                      recintoGroup.addLayer(marcoZeroMarker);

                      // üëâ Aqui voc√™ decide o destino:
                      // A) participar do cluster
                      markersCluster.addLayer(recintoGroup);

            }  

            areas.forEach(area => {
              if (!area.coords || area.coords.length < 1) return;

              // Grupo da √Årea (pai)
              const areaGroup = L.layerGroup();

              // Primeira coordenada (refer√™ncia visual / popup)
              const primeiraCoord = area.coords[0];

              // Pol√≠gono da √Årea
              const areaPolygon = L.polygon(area.coords, { color: area.cor })
                .bindTooltip(
                  "<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' " +
                  "style='vertical-align:middle;margin-right:5px;'/>" +
                  "<strong style='color:" + area.cor + ";'>" + area.titulo + "</strong>",
                  {
                    permanent: false,
                    direction: "top",
                    className: "polygon-label"
                  }
                );
                                
              // Marker de refer√™ncia da √Årea
              const areaMarker = L.marker(primeiraCoord, { icon: marcadorVermelho })
                .bindPopup(
                  "<strong style='color:" + area.cor + ";'>" + area.titulo + "</strong>",
                  { className: 'popup-transparente' }
                );

              // Adiciona tudo ao grupo
              areaGroup.addLayer(areaPolygon);
              areaGroup.addLayer(areaMarker);

              // üëâ Escolha o destino:
              // A) Participar do cluster
              markersCluster.addLayer(areaGroup);

              // B) Ficar fora do cluster (alternativa)
              // mapInstance.addLayer(areaGroup);
            });


          //Abre os tabelaGeo de um cluster
          if(markersCluster)
              markersCluster.on('clusterclick', function (a) {
                a.layer.spiderfy(); // abre o cluster
                a.originalEvent.preventDefault(); // evita comportamento padr√£o
              });

          if(markersCluster)
              markersCluster.on('clusteringend', function () {
                  markersCluster.getLayers().forEach(layer => {
                    if (layer.spiderfy) layer.spiderfy();
                  });
                });

          // Ajusta o zoom para mostrar tudo
    
          if(!markersCluster.getBounds().isValid()) {
            var bounds = L.latLngBounds([[-15.78, -47.93], [-15.75, -47.90]]);
            
            mapInstance.fitBounds(bounds);  
            mapInstance.setZoom(6);    
          } else 
          if(markersCluster)
              mapInstance.fitBounds(markersCluster.getBounds(), { padding: [30, 30] });
      }


      function plotarRecintos(tabelaGeo, mapInstance = map) {
        if (!mapInstance) {
          console.error('Map n√£o inicializado');
          return;
        }

        // --- utils ---------------------------------------------------------

        // Conserta coordenadas no formato "-20.258.360" -> "-20.258360"
        // Remove todos os pontos exceto o √öLTIMO
        const fixCoordDots = (s) => {
          if (s == null) return null;
          const t = String(s).trim();
          if (!t) return null;
          // mant√©m apenas o √∫ltimo ponto decimal
          const cleaned = t.replace(/\.(?=.*\.)/g, '');
          // permite apenas n√∫meros, ponto e sinal de menos
          const sanitized = cleaned.replace(/[^0-9.\-]/g, '');
          const num = parseFloat(sanitized);
          return Number.isFinite(num) ? num : null;
        };

        const normalizeLatLon = (latStr, lonStr) => ({
          lat: fixCoordDots(latStr),
          lon: fixCoordDots(lonStr)
        });

        const normalizeUrl = (u) => {
          if (!u || typeof u !== 'string') return null;
          const t = u.trim();
          if (!t) return null;
          if (/^https?:\/\//i.test(t)) return t;
          return 'https://' + t;
        };

        // --- √≠cone padr√£o (caso customIcon n√£o exista) ---------------------
        const defaultIcon = L.icon({
          iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
          iconRetinaUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon-2x.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });

        const iconToUse = (typeof customIcon !== 'undefined' && customIcon) ? customIcon : defaultIcon;

        // --- loop dos registros --------------------------------------------
        const addedMarkers = [];

        for (let ix = 0; ix < (tabelaGeo?.length ?? 0); ix++) {
          const p = tabelaGeo[ix];

          // plota apenas ativos (boolean true)
          if (p?.Ativo !== true) continue;

          // normaliza coordenadas
          const { lat, lon } = normalizeLatLon(p?.Latitude, p?.Longitude);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
            // pula registros sem coordenadas v√°lidas
            continue;
          }

          const marker = L.marker([lat, lon], { icon: iconToUse })
            .bindPopup(() => {
              const div = document.createElement('div');

              const latText = lat.toFixed(6);
              const lonText = lon.toFixed(6);
              const url = normalizeUrl(p?.URL);
              const urlLink = url ? ` ${url}üîó</a>` : '';

              div.innerHTML = `
                <strong style="color: blue;">${p?.Sigla ?? ''}</strong>
                <ul style="padding-left: 15px; margin: 8px 0 0 0;">
                  <li>${p?.Tipo ?? ''}</li>
                  <li>Recinto: ${p?.Recinto ?? ''}</li>
                  <li>Codigo: ${p?.C√≥digo ?? ''}</li>
                  <li>Latitude: ${latText}</li>
                  <li>Longitude: ${lonText}</li>
                </ul>
              `;

/*
              if (p?.Azimute) {
                try {
    

                  // cria novo
               //   const graf = gerarGraficoAzimute(p.Azimute);
              //    graf.setAttribute('data-azimute-grafico', 'true');
                  div.appendChild(graf);
                } catch(e) {
                  console.warn('Erro ao gerar gr√°fico de azimute:', e);
                }
              }
              */
              return div;

            });

          marker.addTo(mapInstance);
          addedMarkers.push(marker);
        }

        // --- ajustar bounds para mostrar tudo ------------------------------
        if (addedMarkers.length > 0) {
          const bounds = L.latLngBounds(addedMarkers.map(m => m.getLatLng()));
          if (bounds.isValid()) {
            mapInstance.fitBounds(bounds, { padding: [30, 30] });
          }
        } else {
          // fallback (ajuste para sua regi√£o)
          const fallback = L.latLngBounds([[-23, -46], [-19, -40]]);
          mapInstance.fitBounds(fallback);
          mapInstance.setZoom(6);
        }
      }


</script> 

</body>
</html>