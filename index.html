<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Mapa de Recinto Alfandegado</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icone.png">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- MarkerCluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
   /* √çcone fixo no meio do canto direito */
    #flaticon-icon {
      position: fixed;
       bottom: 20px;   /* 1 cm antes do rodap√© */
      right: 10px;
      z-index: 2000; /* acima do mapa */
      cursor: pointer;
    }

    #flaticon-icon img {
      width: 32px;
      height: 32px;
    }
    #map {
      height: 100%;
      width: 100%;
    }
    #map-title {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: transparent; /* fundo totalmente transparente */
      padding: 5px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      font-size: 18px;
      z-index: 1000; /* garante que fica acima do mapa */
      
      /* cor azul no texto */
      color: #2196F3; /* azul m√©dio */
    }

    .map-footer {
      position: fixed;
      bottom: 0;          /* mesma altura da barra de atribui√ß√£o */
      left: 0;
      width: 100%;
      background: transparent;
      padding: 6px 10px;
      font-size: 10px;
      font-family: Arial, sans-serif;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      z-index: 1000;      /* acima do mapa */
    }
    .map-footer-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .map-footer-item img {
      height: 20px;
    }
   #uploadIcon {
      display: inline-block;
      cursor: pointer;
    }
    #uploadIcon svg {
      width: 32px;
      height: 32px;
      fill: #2196F3;
    }
    #fileCSV {
      display: none;
    }
 /* estilo do bot√£o de upload dentro do mapa */
    .leaflet-control-upload {
      background: white;
      border-radius: 4px;
      padding: 4px;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    .leaflet-control-upload svg {
      width: 28px;
      height: 28px;
      fill: #2196F3;
    }
/*
    #btnSelecionar:active {
      box-shadow: 0 2px #0D47A1;
      transform: translateY(2px);
    }
*/

    /* Torna o fundo da janela popup transparente */
    .leaflet-popup-content-wrapper {
      background: rgba(255, 255, 255, 0.75); /* branco com 50% de opacidade */
      box-shadow: none;                     /* remove sombra padr√£o */
      border: none;                         /* remove borda */
    }

  </style>
</head>

<body>
  <p id="siglaRecinto"></p>
    <!-- √çcone de upload -->
     
  <label id="uploadIcon" for="fileCSV" title="Upload de csv contendo coordenadas">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
      <path d="M5 20h14v-2H5v2zm7-18l-7 7h4v6h6v-6h4l-7-7z"/>
    </svg>
  </label>

  <input type="file" id="fileCSV" accept=".csv">

  <div id="map"></div>
  <div id="map-title"></div>
  <!-- √çcone do Flaticon no canto direito -->
  <div id="flaticon-icon">
    <a href="https://www.flaticon.com/br/" 
      title="Flaticon" target="_blank">
      <img src="https://www.flaticon.com/media/img/flaticon-logo.svg" 
          alt="Flaticon logo" style="width:32px;height:32px;">
    </a>
  </div>
  
  <!-- Leaflet JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.min.js"></script>
  <script>
      let pontos = [];    
      //setMapa() 

/*
  function csvParaJson(csvTexto) {
    const linhas = csvTexto.trim().split("\n");
    const cabecalhos = linhas[0].split(/[,;]+/).map(h => h.trim());
    return linhas.slice(1).map(linha => {
      const valores = linha.split(/[,;]+/).map(v => v.trim());
      const objeto = {};
      cabecalhos.forEach((chave, i) => {
        objeto[chave] = valores[i] || "";
      });
      return objeto;
    });
  }

  */
        // Fun√ß√£o que converte CSV em JSON
        function csvParaJson(csvTexto) {
          
    
          const linhas = csvTexto.trim().split("\n");
          const cabecalhos = linhas[0].split(",").map(h => h.trim());

          return linhas.slice(1).map(linha => {
            const valores = linha.split(",").map(v => v.trim());
            const objeto = {};
            cabecalhos.forEach((chave, i) => {
              objeto[chave] = valores[i];
            });
            return objeto;
          });
        }
        function lerCSV(arquivo) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                const json = csvParaJson(reader.result);
                pontos = json;
                resolve(json);
              } catch (e) { reject(e); }
            };
            reader.onerror = () => reject("Erro ao ler arquivo");
            reader.readAsText(arquivo);
          });
        }

        document.getElementById("fileCSV").addEventListener("change", async (event) => {
          const arquivo = event.target.files[0];
          if (!arquivo) return;
          await lerCSV(arquivo);
          console.log("Agora pontos est√° preenchido:", pontos);
          plotarPontosMapa(pontos);
        });

       function getArrayIcones() {
          let arrayIcones = [
                              {tipo: "Balan√ßa (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/512/8248/8248483.png" },
                              {tipo: "Catraca e similares (ponto)", url: "torniquetes.png",icone:"https://cdn-icons-png.flaticon.com/512/3205/3205227.png" },
                              {tipo: "C√¢mera (ponto)", url: "camera-ctv.png",icone: "https://cdn-icons-png.flaticon.com/512/10682/10682215.png"},
                              {tipo: "Port√£o, gate e similares (ponto)", url: "boom_gate2.png",icone:"https://cdn-icons-png.flaticon.com/512/4999/4999239.png" },
                              {tipo: "Port√™iner (ponto)", url: "portainer.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                              {tipo: "Port√™iner, Shiploader ou similares (ponto/pol√≠gono)", url: "portainer.png",icone: "https://cdn-icons-png.flaticon.com/512/11387/11387319.png"},
                              {tipo: "Recinto (pol√≠gono)", url: "area.png",icone: "https://cdn-icons-png.flaticon.com/512/12355/12355988.png"},
                              {tipo: "Scanner (ponto)", url:  "barcode-scanner_2605593.png",icone: "https://cdn-icons-png.flaticon.com/512/4652/4652615.png"},
                              {tipo: "√Årea de armazenamento de lotes (pol√≠gono)", url: "icons8-armaz√©m-80.png",icone:"https://cdn-icons-png.flaticon.com/512/754/754877.png" },
                              {tipo: "√Årea de confer√™ncia f√≠sica (pol√≠gono)", url: "peso.png",icone: "https://cdn-icons-png.flaticon.com/512/16355/16355158.png"},
                              {tipo: "√Årea de posicionamento de cont√™ineres (pol√≠gono)", url: "Container_Red_icon-icons.com_54903.png",icone:"https://cdn-icons-png.flaticon.com/512/1254/1254256.png" },
                              {tipo: "√Årea de posicionamento de ve√≠culos (pol√≠gono)", url: "caminh√£o.png",icone: "https://cdn-icons-png.flaticon.com/512/8397/8397505.png"},                               
                              {tipo: "Tanque de armazenamento (ponto)", url: "TanqueArmazenamento.jpg",icone: "https://cdn-icons-png.flaticon.com/512/5755/5755651.png"},
                              {tipo: "Silo (ponto)", url: "silo.png",icone: "https://cdn-icons-png.flaticon.com/512/2078/2078261.png"},
                              {tipo: "√Årea de controle de carga solta (pol√≠gono)", url: "cargaSolta.png",icone: "https://cdn-icons-png.flaticon.com/512/4829/4829649.png"},
                                //{tipo: "", url: ".png"},
                                //{tipo: "", url: ".png"},
                                //{tipo: "", url: ".png"},                                                                                                

                            ]
          return arrayIcones                  
       }

       function getIcone(icone,azimute) {

            let arrayIcones = getArrayIcones();
            let retorno = './lib/icones/x.png'
            for (let i = 0; i < arrayIcones.length; i++) {
              if (arrayIcones[i].tipo === icone) {
                  retorno = arrayIcones[i].icone
                  break;
              }           
            }
            //Se for c√¢mera e n√£o h√° azimute, entendemos ser c√¢mera dome
            //Retornar endere√ßo do √≠cone de uma dome  
            if(icone.search('C√¢mera')>=0 && !azimute)
               retorno = 'https://cdn-icons-png.flaticon.com/512/9716/9716309.png';
            return retorno;   
       }

       function getPrimeiraOcorrencia(coord) {

           let vetor = coord.split( ' - ')

           //console.log(coord,vetor)
           return vetor[0]

       }
      // Fun√ß√£o que desenha gr√°fico de azimute em canvas
      

        function gerarGraficoAzimute(angulo) {
            const canvas = document.createElement("canvas");
            canvas.width = 200;
            canvas.height = 200;
            const ctx = canvas.getContext("2d");

            // c√≠rculo principal
            ctx.beginPath();
            ctx.arc(100, 100, 80, 0, 2 * Math.PI);
            ctx.stroke();

            // marca√ß√µes principais (N, E, S, W)
            ctx.font = "14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("N", 100, 25);
            ctx.fillText("E", 175, 105);
            ctx.fillText("S", 100, 185);
            ctx.fillText("W", 25, 105);

            // seta indicando o azimute
            const rad = (angulo - 90) * Math.PI / 180; // ajustar para canvas
            const x = 100 + 70 * Math.cos(rad);
            const y = 100 + 70 * Math.sin(rad);

            ctx.beginPath();
            ctx.moveTo(100, 100);
            ctx.lineTo(x, y);
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.stroke();

            // se azimute for diferente de zero, acrescenta c√≠rculo na extremidade
            if (angulo !== 0) {
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, 2 * Math.PI); // c√≠rculo pequeno
              ctx.strokeStyle = "red";
              ctx.lineWidth = 2;
              ctx.stroke();
            }

            return canvas;
        }

        // Fun√ß√£o para calcular azimute em rela√ß√£o ao norte verdadeiro
        function calcularAzimute(lat1, lon1, lat2, lon2) {
          // Converter graus para radianos
          const toRad = deg => deg * Math.PI / 180;
          const toDeg = rad => rad * 180 / Math.PI;

          const dLon = toRad(lon2 - lon1);
          const lat1Rad = toRad(lat1);
          const lat2Rad = toRad(lat2);

          // F√≥rmula de azimute (bearing)
          let y = Math.sin(dLon) * Math.cos(lat2Rad);
          let x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                  Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

          let brng = toDeg(Math.atan2(y, x));
          return (brng + 360) % 360; // normalizar para 0‚Äì360¬∞
        }

       

        function getCoordenada(coordenada) {
             
          if(typeof coordenada === 'string') coordenada = parseFloat(coordenada)
          return coordenada;
        }

        function setMapa() {
            // Inicializa o mapa com OpenStreetMap
            const map = L.map("map", {
              center: [latitudeRecinto, longitudeRecinto], // Vila Velha/ES
              zoom: 12,
              layers: [baseMaps["OpenStreetMap"]]
            }); 

                   // cria controle de upload dentro do mapa
            const UploadControl = L.Control.extend({
              options: { position: 'topright' },
              onAdd: function () {
                const container = L.DomUtil.create('div', 'leaflet-control-upload');
                container.innerHTML = `
                  <label for="fileCSV" title="Selecionar arquivo CSV">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                      <path d="M5 20h14v-2H5v2zm7-18l-7 7h4v6h6v-6h4l-7-7z"/>
                    </svg>
                  </label>
                `;
                return container;
              }
            });
            map.addControl(new UploadControl());
        }
    function plotarPontosMapa(pontos) {

            // ‚úÖ esconder input e label ap√≥s leitura
      document.getElementById("fileCSV").style.display = "none";
      document.getElementById("uploadIcon").style.display = "none";
        //Recinto - Dados devem ser passados 
        let nomeRecinto = pontos[0].NomeRecinto;
        let latitudeRecinto = pontos[0].LatitudeRecinto;
        let longitudeRecinto = pontos[0].LongitudeRecinto;
        let codRecinto = pontos[0].C√≥digoRecinto;
        // Mapas base gratuitos
        const baseMaps = {
          "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "¬© OpenStreetMap"
          }),
          "Carto Light": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png", {
            attribution: "¬© Carto"
          }),
          "Carto Dark": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{r}.png", {
            attribution: "¬© Carto"
          }),
          "Esri World": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles ¬© Esri"
          }),
          // ‚úÖ Sat√©lite Esri
          "Esri Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles ¬© Esri & the GIS community"
          })
        };
        // √çcones ideais para cada mapa
        const baseMapIcons = {
          "OpenStreetMap": "üó∫Ô∏è",       // mapa gen√©rico
          "Carto Light": "üåû",          // estilo claro
          "Carto Dark": "üåô",           // estilo escuro
          "Esri World": "üåç",           // mapa de ruas/mundo
          "Esri Satellite": "üõ∞Ô∏è"       // sat√©lite
        };

        // √çcones da web
        arrayIcones = []


        latitudeRecinto = latitudeRecinto ? latitudeRecinto : parseFloat(-20.329); 
        longitudeRecinto = longitudeRecinto ? longitudeRecinto : parseFloat(-40.292); 
        

      // console.log('coord',pontos.length,pontos[0].Latitude,pontos[0].Longitude,latitude,longitude)
        const nivelZoom = 16;
        const ¬†precisaoAgrupamentoMinimo = 0;
        const ¬†precisaoAgrupamentoMaximo = 80; 
         

        // Inicializa o mapa com OpenStreetMap
        const map = L.map("map", {
          center: [latitudeRecinto, longitudeRecinto], // Vila Velha/ES
          zoom: 12,
          layers: [baseMaps["OpenStreetMap"]]
        });      
        
        ////////////////////////////////
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);

        // Evento de clique no mapa - mostra coordenadas
        map.on("click", function(e) {
          const lat = e.latlng.lat;
          const lng = e.latlng.lng;

          // Refer√™ncia: centro do mapa (pode ser outro ponto fixo)
          const centro = map.getCenter();
          const azimute = calcularAzimute(centro.lat, centro.lng, lat, lng);

          L.popup()
            .setLatLng(e.latlng)
            .setContent(`
              <b>Coordenadas:</b><br>
              Latitude: ${lat.toFixed(6)}<br>
              Longitude: ${lng.toFixed(6)}<br>
              Azimute em rela√ß√£o ao norte: ${azimute.toFixed(2)}¬∞
            `)
            .openOn(map);
        });

        // Define o t√≠tulo
        document.getElementById("map-title").innerHTML = nomeRecinto + ': ' + codRecinto; 
/*
        //Controle personalizado com √≠cone de imagem
        const MapSelector = L.Control.extend({
          options: { position: "topright" },
          onAdd: function () {
            const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");
            container.innerHTML = `<img src="https://cdn-icons-png.flaticon.com/512/854/854878.png" 
                                    alt="map icon" style="width:24px;height:24px;">`;
            container.style.backgroundColor = "white";
            container.style.cursor = "pointer";
            container.style.padding = "5px";

            // Evita que o clique no controle arraste o mapa
            L.DomEvent.disableClickPropagation(container);

            // Ao clicar, abre popup com op√ß√µes
            container.onclick = function () {
              let html = "<b>Selecione o mapa:</b><br>";
              Object.keys(baseMaps).forEach(nome => {
                const icon = baseMapIcons[nome] || "üó∫Ô∏è"; // fallback
                html += `<div style="cursor:pointer; margin:3px; color:blue;" 
                          onclick="window.setBaseMap('${nome}')">${icon} ${nome}</div>`;
              });
              L.popup()
                .setLatLng(map.getCenter())
                .setContent(html)
                .openOn(map);
            };
            return container;
          }
        });

*/

        // cria controle de upload dentro do mapa
        const UploadControl = L.Control.extend({
          options: { position: 'topright' },
          onAdd: function () {
            const container = L.DomUtil.create('div', 'leaflet-control-upload');
            container.innerHTML = `
              <label for="fileCSV" title="Selecionar arquivo CSV">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                  <path d="M5 20h14v-2H5v2zm7-18l-7 7h4v6h6v-6h4l-7-7z"/>
                </svg>
              </label>
            `;
            return container;
          }
        });
        map.addControl(new UploadControl());

        // evento de upload
        document.getElementById("fileCSV").addEventListener("change", (event) => {
          const arquivo = event.target.files[0];
          if (!arquivo) return;

          const reader = new FileReader();
          reader.onload = () => {
            pontos = csvParaJson(reader.result);
            console.log("CSV convertido em JSON:", pontos);
            usarPontos();
            event.target.value = ""; // limpa para permitir re-sele√ß√£o
          };
          reader.readAsText(arquivo);
        });
        //Popup seletor de tipo de mapa. Aparece no canto superior direito
        const MapSelector = L.Control.extend({
          options: { position: "topright" },
          onAdd: function () {
            const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

            container.innerHTML = `
              <img src="https://cdn-icons-png.flaticon.com/512/854/854878.png" 
                  alt="map icon" style="width:24px;height:24px;">
            `;

            // estilo de bot√£o 3D
            container.style.background = "linear-gradient(180deg, #2196F3, #1565C0)"; // azul com gradiente
            container.style.border = "1px solid #0D47A1";
            container.style.borderRadius = "6px";
            container.style.cursor = "pointer";
            container.style.padding = "5px";
            container.style.boxShadow = "0 4px #0D47A1"; // sombra s√≥lida abaixo
            container.style.transition = "all 0.2s ease";

            // efeito ao clicar
            container.onmousedown = function () {
              container.style.boxShadow = "0 2px #0D47A1";
              container.style.transform = "translateY(2px)";
            };
            container.onmouseup = function () {
              container.style.boxShadow = "0 4px #0D47A1";
              container.style.transform = "translateY(0)";
            };

            // Evita que o clique no controle arraste o mapa
            L.DomEvent.disableClickPropagation(container);

            // Ao clicar, abre popup com op√ß√µes
            container.onclick = function () {
              let html = "<b>Selecione o mapa:</b><br>";
              Object.keys(baseMaps).forEach(nome => {
                const icon = baseMapIcons[nome] || "üó∫Ô∏è"; // fallback
                html += `<div style="cursor:pointer; margin:3px; color:blue;" 
                          onclick="window.setBaseMap('${nome}')">${icon} ${nome}</div>`;
              });
              L.popup()
                .setLatLng(map.getCenter())
                .setContent(html)
                .openOn(map);
            };

            return container;
          }
        });
        
        map.addControl(new MapSelector());

        // Fun√ß√£o global para trocar mapa base
        window.setBaseMap = function (nome) {
          map.eachLayer(layer => {
            if (layer instanceof L.TileLayer) {
              map.removeLayer(layer);
            }
          });
          baseMaps[nome].addTo(map);
        };

        // Grupo de clusters
        let markersCluster = L.markerClusterGroup(
                                  {
                                    spiderfyOnEveryZoom: false, // n√£o fechar ao dar zoom
                                    removeOutsideVisibleBounds: false, // mant√©m clusters fora da √°rea vis√≠vel
                                    disableClusteringAtZoom: null, // mant√©m agrupamento
                                                                  maxClusterRadius: function (zoom) {
                                            return zoom < 10 ? precisaoAgrupamentoMaximo: precisaoAgrupamentoMinimo;

                                                                      }
                                  
                                }
                                );

        // Array para armazenar coordenadas das casas
        let poligonoRecinto = []; 
        let poligonoAreaVeiculo = []; 
        let poligonoAreaLote = []; 
        let poligonoAreaCargaSolta = [];     
        let poligonoAreaConteiner = []; 
        let poligonoConferencia = []; 
        let poligonoPorteiner = [];     


        for (let ix = 0; ix < pontos.length; ix++) {  
       
          let p = pontos[ix]
          
          if(p.Ativo != 'true') continue
   

          //Validar se √© ponto ou √°rea
          //Ponto n√£o pode ter pol√≠gono no p.Tipo
          let indPoligono = p.Tipo.search('pol√≠gono') >=0 ? true : false

          let iconURL = getIcone(p.Tipo,p.Azimute)

          const customIcon = L.icon({
            iconUrl: iconURL,
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            popupAnchor: [0, -32]
            });
              
          latitude  = ''
          longitude = ''

          if(indPoligono) {
      

              let arrayLatitude = p.Latitude.split(' - ')
              let arrayLongitude = p.Longitude.split(' - ')

              let ultimaLatitude  = getCoordenada(arrayLatitude[0]); 
              let UltimaLongitude = getCoordenada(arrayLongitude[0]) ;         
              for (let lx = 0; lx < arrayLatitude.length; lx++) {  

                  if (p.Tipo.search('Recinto')>=0) { 
                      poligonoRecinto.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoRecinto.push([ultimaLatitude, UltimaLongitude]);
                      }
                  }
                  if (p.Tipo.search('ve√≠culos')>=0) { 
                      
                      poligonoAreaVeiculo.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoAreaVeiculo.push([ultimaLatitude, UltimaLongitude]);                        
                         poligonoAreaVeiculo.push([getCoordenada(arrayLatitude[0]) , getCoordenada(arrayLongitude[0])]);
                      }                        

                  }                       
                  if (p.Tipo.search('lotes')>=0){ 
                     poligonoAreaLote.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoAreaLote.push([ultimaLatitude, UltimaLongitude]);                        
                         
                      }                     
           
                  }                          
                  if (p.Tipo.search('confer√™ncia f√≠sica')>=0) { 
                 
                     poligonoConferencia.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoConferencia.push([ultimaLatitude, UltimaLongitude]);                        
                         
                      }                       
 
                  }                                           
                  if (p.Tipo.search('cont√™ineres')>=0) {                 
                      poligonoAreaConteiner.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoAreaConteiner.push([ultimaLatitude, UltimaLongitude]);                        
                        
                      }

                  }                                         
                        
                  if (p.Tipo.search('carga solta')>=0) { 
                      poligonoAreaCargaSolta.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoAreaCargaSolta.push([ultimaLatitude, UltimaLongitude]);                        
                        
                      }                      

                  }                                             
                      
                  if (p.Tipo.search('Port√™iner')>=0) { 
                  
                    poligonoPorteiner.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                      //Para fechar o pol√≠gono
                      if(lx + 1 === arrayLatitude.length) {
                         poligonoPorteiner.push([ultimaLatitude, UltimaLongitude]);                        
                        
                      }                         
                                            
                  }     
                    
                    



              }

          } 
          if(!indPoligono) { 
              if(p.Latitude === '') continue; 
              latitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)));
              longitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)));
              let azimute = p.Azimute ? p.Azimute : 0.
             // if(typeof latitude === 'string') latitude = parseFloat(latitude)
             // if(typeof longitude === 'string') longitude = parseFloat(longitude) 
 
              // Marker com popup contendo texto + gr√°fico
              let marker = L.marker([latitude, longitude], { icon: customIcon })
                .bindPopup(() => {
                  // conte√∫do textual
                  const div = document.createElement("div");
                  
                  div.innerHTML = `
                    <ul style="padding-left: 15px; margin: 0;">
                      <li><strong>${p.Equipamento}</strong></li>
                      <li>Azimute: ${azimute}</li>                      
                      <li>Latitude: ${(parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude))))}</li>
                      <li>Longitude: ${(parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude))))}</li>

                    </ul>
                  `;
                  // adiciona gr√°fico de azimute (exemplo: 45¬∞)
                  div.appendChild(gerarGraficoAzimute(azimute));
                  return div;
                });

            markersCluster.addLayer(marker);


            
          }
        }

        map.addLayer(markersCluster);

        // JSON com array de 5 itens
        const rodapeInfo = [
          { titulo: "√Årea:", icone: "", cor: 'navy' },                   
          { titulo: "Recinto", icone: "", cor: 'navy' },
          { titulo: "Carga Solta", icone: "" , cor: 'purple'},      
          { titulo: "Confer√™ncia", icone: "" , cor: 'orange'},
          { titulo: "Cont√™iner", icone: "", cor: 'red' },
          { titulo: "Lote", icone: "" , cor: 'green'},          
          { titulo: "Port√™iner", icone: "" , cor: 'black'},         
  
          { titulo: "Ve√≠culo", icone: "" , cor: 'darkcyan'}
        ];

      


        // Pol√≠gono do Recinto

        if (poligonoRecinto.length >= 1) {
      
          L.polyline(poligonoRecinto, {
            color: rodapeInfo[1].cor,   // ‚úÖ acesso direto
            weight: 2,                  // espessura
            opacity: 0.8                // transpar√™ncia
            // dashArray: '10, 10'      // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }
        // √Årea de posicionamento de ve√≠culos (pol√≠gono)
        if (poligonoAreaVeiculo.length >= 1) {
           
          L.polygon(poligonoAreaVeiculo, {
            color: rodapeInfo[7].cor,       // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }
        // √Årea de posicionamento de Lotes
        if (poligonoAreaLote.length >=1) {
          
          L.polygon(poligonoAreaLote, {
            color: rodapeInfo[5].cor,       // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }
        // √Årea de posicionamento de poligonoAreaCargaSolta
        if (poligonoAreaCargaSolta.length >= 1) {
           
          L.polygon(poligonoAreaCargaSolta, {
            color: rodapeInfo[2].cor,       // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }
        // √Årea de posicionamento de poligonoAreaConteiner
        if (poligonoAreaConteiner.length >= 1) {
          
          L.polygon(poligonoAreaConteiner, {
            color: rodapeInfo[4].cor,       // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }   
        // √Årea de posicionamento de poligonoConferencia
        if (poligonoConferencia.length >= 1) {
           
          L.polygon(poligonoConferencia, {
            color: rodapeInfo[3].cor,      // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }  
        // √Årea de posicionamento de poligonoPorteiner
        if (poligonoPorteiner.length >= 1) {
           
          L.polygon(poligonoPorteiner, {
            color: rodapeInfo[6].cor,      // cor da linha
            weight: 2,          // espessura
            opacity: 0.6,       // transpar√™ncia
          // dashArray: '10, 10' // tracejada (10px tra√ßo, 10px espa√ßo)
          }).addTo(map);
        }     

        //Abre os pontos de um cluster
        
      markersCluster.on('clusterclick', function (a) {
        a.layer.spiderfy(); // abre o cluster
        a.originalEvent.preventDefault(); // evita comportamento padr√£o
      });


        markersCluster.on('clusteringend', function () {
          markersCluster.getLayers().forEach(layer => {
            if (layer.spiderfy) layer.spiderfy();
          });
        });

        // Controle personalizado
        const footer = L.control({position: 'bottomleft'});
        footer.onAdd = function () {
          const div = L.DomUtil.create('div', 'map-footer');
          div.innerHTML = rodapeInfo.map(item => `
            <div class="map-footer-item" style="color:${item.cor};">
              <span><strong>${item.titulo}</strong></span>
            </div>
          `).join("");
          return div;
        };

        footer.addTo(map);  


        // Ajusta o zoom para mostrar tudo
        map.fitBounds(markersCluster.getBounds(), { padding: [30, 30] });
  }
 

</script> 

  <script>
/*
    let geoPloter = null;
   
    (async () => {
      geoPloter = await lerDoStorage("ploter");
      inicializarMapa(geoPloter)
    })();
*/   

  
 
 </script>
</body>
</html>