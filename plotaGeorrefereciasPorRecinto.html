<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Mapa de Recinto Alfandegado</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icone.png">
    <!-- Leaflet CSS 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.css">    
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <!-- MarkerCluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
   /* √çcone fixo no meio do canto direito */

    #flaticon-icon {
      position: absolute;   /* fixa na tela */
      bottom: 10px;      /* dist√¢ncia da borda inferior */
      right: 10px;       /* dist√¢ncia da borda direita */
      z-index: 10000;     /* garante que fique acima do mapa/outros elementos */
    }


    #flaticon-icon img {
      width: 32px;
      height: 32px;
    }
    #map {
      height: 100%;
      width: 100%;
      position: relative;
    }
    #map-title {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-60%);
      background: transparent; /* fundo totalmente transparente */
      padding: 5px 15px;
      border-radius: 5px;
      font-family: Arial, sans-serif;
      font-weight: bold;
      font-size: 30px;
      z-index: 1000; /* garante que fica acima do mapa */
      
      /* cor azul no texto */
      color: #2196F3; /* azul m√©dio */
    }

    .map-footer {
      position: fixed;
      bottom: 0;          /* mesma altura da barra de atribui√ß√£o */
      left: 0;
      width: 100%;
      background: transparent;
      padding: 6px 10px;
      font-size: 10px;
      font-family: Arial, sans-serif;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      z-index: 1000;      /* acima do mapa */
    }
    .map-footer-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .map-footer-item img {
      height: 20px;
    }
 /* Painel lateral */
    .painel-tabela {
      position: absolute;
      top: 50px;
      right: 10px;
      width: 60%;
      height: 70%;
      background: white;
      border: 2px solid #0D47A1;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      overflow-x: auto;   /* üëà permite rolar para a esquerda/direita */
      overflow-y: auto;   /* üëà mant√©m rolagem vertical */
      display: none;
      z-index: 1000;
      padding: 10px;
      font-size: 8px;
      min-width: 900px;   /* for√ßa largura m√≠nima */
    }

    /* Bot√£o fechar dentro do painel */
    .painel-tabela .fechar {
      float: right;
      cursor: pointer;
      font-weight: bold;
      color: darkred;
      margin-bottom: 10px;
    }   
    /* painel tabela */

    .painel-tabela h2 {
      margin: 0 0 8px 0;
      font-size: 13px;
      color: #0D47A1;
    }

    /* ===============================
       WRAPPER (SCROLL)
    =============================== */
    .painel-tabela .table-wrapper {
      overflow-x: auto;
      overflow-x: auto;   /* üëà permite rolar horizontalmente */
      max-height: 70vh;
      border: 1px solid #ddd;
    }

    /* ===============================
       TABELA
    =============================== */
    .painel-tabela table {
      width: 100%;
      border-collapse: collapse;
      table-layout: auto;   /* ou fixed, mas com min-width */
      min-width: 900px;     /* üëà for√ßa largura maior que tela */
    }
    .painel-tabela table th:nth-child(1),
    .painel-tabela table td:nth-child(1) {
      width: 35px;       /* largura fixa Tipo*/
      max-width: 35px;
      text-align: center;
    }    
    .painel-tabela table th:nth-child(2),
    .painel-tabela table td:nth-child(2) {
      width: 50px;       /* largura fixa Equipamento */
      max-width: 50px;
      text-align: center;
    }
    .painel-tabela table th:nth-child(3),
    .painel-tabela table td:nth-child(3) {
      width: 2px;       /* largura fixa Ativo*/
      max-width: 2px;
      text-align: center;
    }
    .painel-tabela table th:nth-child(4),
    .painel-tabela table td:nth-child(4) {
      width: 35px;       /* largura fixa Protocolo*/
      max-width: 35px;
      text-align: center;
    }    
    .painel-tabela table th:nth-child(5),
    .painel-tabela table td:nth-child(5) {
      width: 2px;       /* largura fixa Azimute*/
      max-width: 2px;
      text-align: center;
    }  
    .painel-tabela table th:nth-child(6),
    .painel-tabela table td:nth-child(6) {
      width: 8px;       /* largura fixa Latitude*/
      max-width: 8px;
      text-align: center;
    } 
    .painel-tabela table th:nth-child(7),
    .painel-tabela table td:nth-child(7) {
      width: 9px;       /* largura fixa Longitude*/
      max-width: 9px;
      text-align: center;
    }
    .painel-tabela table th:nth-child(8),
    .painel-tabela table td:nth-child(8) {
      width: 8px;       /* largura fixa Plotaar*/
      max-width: 8px;
      text-align: center;
    }
    .painel-tabela thead {
      background: #f1f1f1;   /* fundo cinza claro */
      color: black;          /* texto preto */
      font-weight: bold;     /* negrito */
      position: sticky;
      top: 0;
      z-index: 2;
    }
    .painel-tabela th,
    .painel-tabela td {
      padding: 3px 5px;
      border: 1px solid #ddd;
      text-align: center;
      white-space: nowrap;
    }

    .painel-tabela tbody tr:nth-child(even) {
      background: #f9f9f9;
    }

    .painel-tabela tbody tr:hover {
      background: #e3f2fd;
    }

    /* ===============================
       BOT√ÉO PLOTAR
    =============================== */
    .painel-tabela .btn-plotar {
      background: linear-gradient(180deg, #2196F3, #1565C0);
      border: 1px solid #0D47A1;
      border-radius: 4px;
      color: white;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 9px;
      box-shadow: 0 2px #0D47A1;
      padding: 1px 4px;
    }

    .painel-tabela .btn-plotar:active {
      box-shadow: 0 1px #0D47A1;
      transform: translateY(1px);
    }

    /* ===============================
       MOBILE
    =============================== */
    @media (max-width: 768px) {
      body {
        padding: 4px;
      }
      .painel-tabela {
        width: 95%;        /* ocupa quase toda a tela */
        min-width: auto;   /* üëà remove largura m√≠nima */
        left: 2%;          /* centraliza melhor */
        right: auto;
      }
      .painel-tabela .table-wrapper {
         overflow-x: auto;   /* garante scroll horizontal */
      }
      .painel-tabela h2 {
        font-size: 12px;
      }

      .painel-tabela table {
        font-size: 8px;
      }

      .painel-tabela .btn-plotar {
        font-size: 10px;
        padding: 2px 4px;
      }
    }

    /* // */
    .polygon-label {
      font-weight: bold;
      font-size: 10px;
      color: #000;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .popup-transparente .leaflet-popup-content-wrapper {
      background: transparent;
      box-shadow: none;
    }

    .popup-transparente .leaflet-popup-tip {
      background: transparent;
    }
   .popup-table {
      max-height: 300px;
      overflow: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: left;
    }
    th {
      background-color: #f0f0f0;
    }
    .text-label {
      font-size: 14px;
      font-weight: bold;
      color: darkblue;
      background: rgba(255,255,255,0.7);
      padding: 2px 6px;
      border-radius: 4px;
    }
    .tooltip-transparent {
      background: transparent !important; /* remove fundo */
      border: none !important;            /* remove borda */
      box-shadow: none !important;        /* remove sombra */
      color: blue;                        /* cor do texto */
      font-weight: bold;
    }    
   #uploadIcon {
      position: fixed;   /* fixa na tela */
      display: inline-block;
      cursor: pointer;
      top: 20px; 
      right: 20px;       /* dist√¢ncia da direita */
    
      text-align: center;
    }
    #uploadIcon svg {
      width: 32px;
      height: 32px;
      fill: #2196F3;
    }
    #fileCSV {
      display: none;
    }

    .leaflet-control-custom {
      background-color: white;
      background-size: 20px 20px;
      cursor: pointer;
      font-size: 20px;
      padding: 5px;
    }    
   /* estilo do bot√£o de upload dentro do mapa */
   
    .leaflet-control-upload {
      background: white;
      border-radius: 4px;
      padding: 4px;
      cursor: pointer;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
    }
    .leaflet-control-upload svg {
      width: 28px;
      height: 28px;
      fill: #2196F3;
    }

    
/*
    #btnSelecionar:active {
      box-shadow: 0 2px #0D47A1;
      transform: translateY(2px);
    }
*/

    /* Torna o fundo da janela popup transparente */
    .leaflet-popup-content-wrapper {
      background: rgba(255, 255, 255, 0.75); /* branco com 50% de opacidade */
      box-shadow: none;                     /* remove sombra padr√£o */
      border: none;                         /* remove borda */
    }

  </style>
</head>

<body>
  <p id="siglaRecinto"></p>

  <input type="file" id="fileCSV" accept=".csv">

  <div id="map">
      <div id="flaticon-icon">
        <a href="https://www.flaticon.com/br/" title="Flaticon" target="_blank">
          <img 
            src="https://www.flaticon.com/media/img/flaticon-logo.svg"
            alt="Flaticon logo">
        </a>
        <div id="flaticon-icon"></div>
      </div>

  </div>
  <div id="map-title"></div>

  <div id="painelTabela" class="painel-tabela" style="display:none;">
    <span class="fechar" onclick="document.getElementById('painelTabela').style.display='none'">X</span>
    <div class="table-wrapper">
      <!-- tabela ser√° injetada aqui -->
    </div>
  </div>


  
    
  

  <!-- Leaflet JS 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  -->
  <script src="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.js"></script>
   
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.min.js"></script>
  <script>
      //Vari√°veis e constantes globais
      const nivelZoom = 18;
      const ¬†precisaoAgrupamentoMinimo = 0;
      const ¬†precisaoAgrupamentoMaximo = 80;
      // Array para armazenar coordenadas das casas
      let poligonoRecinto = []; 
       
      // JSON com array de 5 itens
      const rodapeInfo = [
        { titulo: "√Årea:", icone: "", cor: 'navy' },                   
        { titulo: "Recinto", icone: "", cor: 'navy' },
                         ];    
      const areas = [
        { coords: [], titulo: "Posicionamento de Ve√≠culo", cor: 'darkcyan' },
        { coords: [], titulo: "Armazenamento de Lotes", cor: 'green' },
        { coords: [], titulo: "Controle de Carga Solta", cor: 'purple' },
        { coords: [], titulo: "Posicionamento de Cont√™iner",cor: 'red' },
        { coords: [], titulo: "Confer√™ncia F√≠sica", cor: 'orange' },
        { coords: [], titulo: "Port√™iner, Shiploader ou similares", cor: 'black' },
        { coords: [], titulo: "Port√™iner Shiploader ou similares", cor: 'black' }          
                         ];   

      // Estado da fun√ß√£o de inibir apresenta√ß√£o de coordenadas no mapa
      let clickEnabled = false;
      isTracing = false; //Mostra dados na console
      // Grupo de clusters
      let markersCluster ;
      let pontos = [{Tipo: "", Equipamento: "", Azimute: 0, Longitude: 0, Latitude: 0}
                   ];      
          
             
      // Mapas base gratuitos
        const baseMaps = {
          "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "¬© OpenStreetMap"
          }),
          "Carto Light": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png", {
            attribution: "¬© Carto"
          }),
          "Carto Dark": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{r}.png", {
            attribution: "¬© Carto"
          }),
          "Esri World": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles ¬© Esri"
          }),
          // ‚úÖ Sat√©lite Esri
          "Esri Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
            attribution: "Tiles ¬© Esri & the GIS community"
          })
        };

        // √çcones ideais para cada mapa
        const baseMapIcons = {
          "OpenStreetMap": "üó∫Ô∏è",       // mapa gen√©rico
          "Carto Light": "üåû",          // estilo claro
          "Carto Dark": "üåô",           // estilo escuro
          "Esri World": "üåç",           // mapa de ruas/mundo
          "Esri Satellite": "üõ∞Ô∏è"       // sat√©lite
        };  

      //Mapa
       let map;

      // Controle customizado
      let popupAberto = false;
      let popupRef = null;
    
      initMapa();
      plotarPontosMapa(pontos);
  // Fun√ß√£o para gerar HTML da tabela
    function gerarTabelaHTML(tabela) {
      if (!tabela || tabela.length === 0 || tabela[0].Tipo === '') {
        return "";
      }
      let html = `
        <table id="tabelaPonto">
          <thead>
            <tr>
              <th>Tipo</th>
              <th>Equipamento</th>
              <th style="width:10px;">Ativo</th>              
              <th style="width:50px;">Protocolo</th>
              <th style="width:50px;">Azimute</th>
              <th style="width:50px;">Latitude</th>
              <th style="width:50px;">Longitude</th>

              <th style="width:50px;">Plotar</th> 
            </tr>
          </thead>
          <tbody>
      `;
      tabela.forEach((p) => {
        html += `
          <tr>
            <td>${p.Tipo}</td>
            <td>${p.Equipamento}</td>
            <td>${p.Ativo}</td>
            <td>${p.Protocolo}</td>
           
            <td>${p.Azimute}</td>
            <td>${p.Latitude}</td>
            <td>${p.Longitude}</td>
            <td>
              <button
                        onclick="plotarNoMapa(
                          ${p.Latitude},
                          ${p.Longitude},
                          '${p.Tipo}',
                          '${p.Equipamento}',
                          ${p.Azimute}
                        )"
                        style="
                          background: linear-gradient(180deg, #2196F3, #1565C0);
                          border: 1px solid #0D47A1;
                          border-radius: 6px;
                          color: white;
                          padding: 5px 10px;
                          cursor: pointer;
                          box-shadow: 0 4px #0D47A1;
                          transition: all 0.2s ease;
                        "
                        onmousedown="this.style.boxShadow='0 2px #0D47A1'; this.style.transform='translateY(2px)'"
                        onmouseup="this.style.boxShadow='0 4px #0D47A1'; this.style.transform='translateY(0)'"
                      >
                        üìç
                      </button>

            </td> 
          </tr>
        `;
      });
      html += `</tbody></table>`;
      return html;
    }


    // Fun√ß√£o para plotar marcador no mapa com mais informa√ß√µes
    function plotarNoMapa(lat, lng, tipo, equipamento, azimute) {
      L.circleMarker([lat, lng], {
        radius: 8,
        color: '#b71c1c',
        fillColor: '#e53935',
        fillOpacity: 0.9
      })
      .addTo(map)
      .bindPopup(`
        <strong style="color: darkblue;">${tipo}</strong>
        <ul style="padding-left: 15px; margin: 0;">
          <li>${equipamento}</li>
          <li>Latitude: ${lat}</li>
          <li>Longitude: ${lng}</li>
          ${azimute ? `<li>Azimute: ${azimute}</li>` : ""}
        </ul>
      `)
      .openPopup();

      map.setView([lat, lng], 15);
        // ‚úÖ Fecha o painel lateral
      const painel = document.getElementById("painelTabela");

      if (painel) {
        painel.style.display = "none";
      }
    }

    // Controle Leaflet para abrir/fechar painel
    L.Control.Excel = L.Control.extend({
      onAdd: function(map) {
        const btn = L.DomUtil.create('button', 'leaflet-bar leaflet-control leaflet-control-custom');
        btn.innerHTML = `
          <img src="https://cdn-icons-png.flaticon.com/512/2535/2535554.png" 
              alt="Coordenadas" style="width:23px;height:20px;">
        `;
        btn.title = "Apresenta/oculta tabela de Coordenadas";
        L.DomEvent.disableClickPropagation(btn);

    btn.onclick = function() {
      const painel = document.getElementById("painelTabela");
      const wrapper = painel.querySelector(".table-wrapper");
      if (painel.style.display === "none" || painel.style.display === "") {
        const htmlTabela = gerarTabelaHTML(pontos);
        if (htmlTabela === "") return;
        if (wrapper) {
           wrapper.innerHTML = htmlTabela;
        }
        //painel.querySelector(".conteudo").innerHTML = htmlTabela; // s√≥ atualiza a parte da tabela
        painel.style.display = "block";

        // Inicializa DataTable
        setTimeout(() => {
          const tabela = document.querySelector("#tabelaPonto");
          if (tabela) {
            new DataTable(tabela, {
              searchable: true,
              sortable: true,
              perPage: 15,
              labels: {
                placeholder: "Buscar...",
                perPage: "{select} registros por p√°gina",
                noRows: "Nenhum registro encontrado",
                info: "Mostrando {start} at√© {end} de {rows} registros"
              }
            });
          }
        }, 200);
      } else {
        painel.style.display = "none";
      }
    };
    
    return btn;
        },
        onRemove: function(map) {}
    }
  
  );

    map.addControl(new L.Control.Excel({ position: "topright" }));
      //Fun√ß√£o inicializar mapa

      function initMapa() {
        if(isTracing) console.log('InitMapa');
          // Inicializa o mapa com OpenStreetMap
          map = L.map("map", {
            center: [-15.7797 , -47.9297], // Bras√≠lia
            zoom: 6,                 // zoom inicial
            minZoom: 0,               // zoom m√≠nimo permitido
            maxZoom: 20,              // zoom m√°ximo permitido            
            layers: [baseMaps["OpenStreetMap"]]
          });     
          map.setView([-15.7797, -47.9297], 6)
          /* Valores mais comuns de zoom
              üîπ Valores mais comuns
              Zoom	Descri√ß√£o
              0	Mundo inteiro
              5	Pa√≠s
              10	Cidade
              13	Bairro
              16	Quadras
              18	Rua
              20‚Äì22	Detalhe m√°ximo (depende do mapa)
          */
          ////////////////////////////////
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
          }).addTo(map);

   
          // Fun√ß√£o de clique no mapa
          function onMapClick(e) {

            if (!clickEnabled) return;

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            const centro = map.getCenter();
            const azimute = calcularAzimute(centro.lat, centro.lng, lat, lng);

            const canvas = gerarGraficoAzimute(azimute);

            const container = document.createElement("div");
            container.innerHTML = `
              <b>Coordenadas:</b><br>
              Latitude: ${lat.toFixed(6)}<br>
              Longitude: ${lng.toFixed(6)}<br>
              Azimute em rela√ß√£o ao norte: ${azimute.toFixed(2)}¬∞
              <br><br>
            `;
            container.appendChild(canvas);

            L.popup()
              .setLatLng(e.latlng)
              .setContent(container)
              .openOn(map);
          }

          // Controle personalizado
          const ToggleCoordsControl = L.Control.extend({
            options: { position: "topright" },

            onAdd: function () {
              const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

              // √çcone FontAwesome (ex.: localiza√ß√£o cruzada)
              container.innerHTML = '<i class="fa-solid fa-crosshairs"></i>';
              container.style.backgroundColor = "white";
              container.style.cursor = "pointer";
              container.style.fontSize = "18px";
              container.style.textAlign = "center";
              container.style.lineHeight = "30px";
              container.style.width = "23px";
              container.style.height = "27px";

              container.onclick = function () {
                if (clickEnabled) {
                  map.off("click", onMapClick);
                  clickEnabled = false;
                  container.style.backgroundColor = "white"; // desligado
                } else {
                  map.on("click", onMapClick);
                  clickEnabled = true;
                  container.style.backgroundColor = "#cce5ff"; // ligado
                }
              };

              return container;
            }
          });

          // Adicionar controle ao mapa
          map.addControl(new ToggleCoordsControl());

////
          // cria controle de upload dentro do mapa
          const UploadControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function () {
              const container = L.DomUtil.create('div', 'leaflet-control-upload');
              container.innerHTML = `
                <label for="fileCSV" title="Selecionar arquivo CSV">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                    <path d="M5 20h14v-2H5v2zm7-18l-7 7h4v6h6v-6h4l-7-7z"/>
                  </svg>
                </label>
              `;
              return container;
            }
          });
          map.addControl(new UploadControl());

          // evento de upload
          document.getElementById("fileCSV").addEventListener("change", (event) => {
            const arquivo = event.target.files[0];
            if (!arquivo) return;

            const reader = new FileReader();
            reader.onload = () => {
              pontos = csvParaJson(reader.result);

              //setPontos(pontos);
              event.target.value = ""; // limpa para permitir re-sele√ß√£o
            };
            reader.readAsText(arquivo);
          });

          //Popup seletor de tipo de mapa. Aparece no canto superior direito
 
          const MapSelector = L.Control.extend({
            options: { position: "topright" },
            onAdd: function () {
              const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

              container.innerHTML = `
                <img src="https://cdn-icons-png.flaticon.com/512/854/854878.png" 
                    alt="map icon" style="width:23px;height:20px;">
              `;

              // estilo de bot√£o 3D
              container.style.background = "linear-gradient(180deg, #2196F3, #1565C0)";
              container.style.border = "1px solid #0D47A1";
              container.style.borderRadius = "6px";
              container.style.cursor = "pointer";
              container.style.padding = "5px";
              container.style.boxShadow = "0 4px #0D47A1";
              container.style.transition = "all 0.2s ease";

              // efeito ao clicar
              container.onmousedown = function () {
                container.style.boxShadow = "0 2px #0D47A1";
                container.style.transform = "translateY(2px)";
              };
              container.onmouseup = function () {
                container.style.boxShadow = "0 4px #0D47A1";
                container.style.transform = "translateY(0)";
              };

              // Evita que o clique no controle arraste o mapa
              L.DomEvent.disableClickPropagation(container);

              // Vari√°veis de controle
              let popupAberto = false;
              let popupRef = null;

              // Ao clicar, abre/fecha popup com op√ß√µes
              container.onclick = function () {
                if (!popupAberto) {
                  let html = "<b>Selecione o mapa:</b><br>";
                  Object.keys(baseMaps).forEach(nome => {
                    const icon = baseMapIcons[nome] || "üó∫Ô∏è"; // fallback
                    html += `<div style="cursor:pointer; margin:3px; color:blue;" 
                              onclick="window.setBaseMap('${nome}')">${icon} ${nome}</div>`;
                  });
                  popupRef = L.popup({ maxWidth: 300 })
                    .setLatLng(map.getCenter())
                    .setContent(html)
                    .openOn(map);
                  popupAberto = true;
                } else {
                  map.closePopup(popupRef);
                  popupAberto = false;
                }
              };

              return container;
            }
          });

    
          
          map.addControl(new MapSelector());
          // Fun√ß√£o global para trocar mapa base
          window.setBaseMap = function (nome) {
            map.eachLayer(layer => {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            baseMaps[nome].addTo(map);
          };
  
          // Grupo de clusters
          markersCluster = L.markerClusterGroup({
                                spiderfyOnEveryZoom: false, // n√£o fechar ao dar zoom
                                removeOutsideVisibleBounds: false, // mant√©m clusters fora da √°rea vis√≠vel
                                disableClusteringAtZoom: null, // mant√©m agrupamento
                                maxClusterRadius: function (zoom) {
                                                  return zoom < 10 ? precisaoAgrupamentoMaximo: precisaoAgrupamentoMinimo;
                                                                  }
                                      });
          // ‚úÖ Aqui voc√™ registra o evento
          map.on("click", onMapClick);

      }
   
   /*           
      function plotarNoMapa(lat, lng,tipo,equipamento,aziumte) {
        L.marker([lat, lng])
          .addTo(map)
          .bindPopup(
          `
                        <strong style="color: darkbleu;">${p.Tipo}</strong>
                          <ul style="padding-left: 15px; margin: 0;">
                            <li>${p.Equipamento}</li>
                            <li>Latitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)))}</li>
                            <li>Longitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)))}</li>

                            ${p.Azimute ? `<li>Azimute: ${p.Azimute}</li>` : ""}
                          </ul>
                      
                      `  
                                 
                    )
          .openPopup();

        map.setView([lat, lng], 15);

        // ‚úÖ Fecha o painel lateral ap√≥s plotar
        const painel = document.getElementById("painelTabela");
        if (painel) {
          painel.style.display = "none";
        }
      }
*/

        // Fun√ß√£o que converte CSV em JSON
        function csvParaJson(csvTexto) {
       
    
          const linhas = csvTexto.trim().split("\n");
          const cabecalhos = linhas[0].split(",").map(h => h.trim());

          return linhas.slice(1).map(linha => {
            const valores = linha.split(",").map(v => v.trim());
            const objeto = {};
            cabecalhos.forEach((chave, i) => {
              objeto[chave] = valores[i];
            });
            return objeto;
          });
        }

        function lerCSV(arquivo) {
          if(isTracing) console.log('lerCSV')       
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                const json = csvParaJson(reader.result);
                pontos = json;
                resolve(json);
              } catch (e) { 
             
                reject(e); }
            };
            reader.onerror = () => {
              

             reject("Erro ao ler arquivo");}
            reader.readAsText(arquivo);
          });
        }

          document.getElementById("fileCSV").addEventListener("change", async (event) => {
            if(isTracing) console.log('getElementById');
            const arquivo = event.target.files[0];
            if (!arquivo) return;
          
            await lerCSV(arquivo);

            plotarPontosMapa(pontos);
        });

        function getArrayIcones() {
          let arrayIcones = [
                              {tipo: "Recinto (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/128/684/684908.png" },
                              {tipo: "Balan√ßa (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/512/8248/8248483.png" },
                              {tipo: "Catraca e similares (ponto)", url: "torniquetes.png",icone:"https://cdn-icons-png.flaticon.com/512/1185/1185509.png" },
                              {tipo: "C√¢mera (ponto)", url: "camera-ctv.png",icone: "https://cdn-icons-png.flaticon.com/512/10073/10073813.png"},
                              {tipo: "Port√£o, gate e similares (ponto)", url: "boom_gate2.png",icone:"https://cdn-icons-png.flaticon.com/512/4999/4999239.png" },
                              {tipo: "Port√™iner (ponto)", url: "portainer.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                              
                              {tipo: "Recinto (pol√≠gono)", url: "area.png",icone: "https://cdn-icons-png.flaticon.com/512/12355/12355988.png"},
                              {tipo: "Scanner (ponto)", url:  "barcode-scanner_2605593.png",icone: "https://cdn-icons-png.flaticon.com/512/4652/4652615.png"},
                              {tipo: "√Årea de armazenamento de lotes (pol√≠gono)", url: "icons8-armaz√©m-80.png",icone:"https://cdn-icons-png.flaticon.com/512/754/754877.png" },
                              {tipo: "√Årea de confer√™ncia f√≠sica (pol√≠gono)", url: "peso.png",icone: "https://cdn-icons-png.flaticon.com/512/16355/16355158.png"},
                              {tipo: "√Årea de posicionamento de cont√™ineres (pol√≠gono)", url: "Container_Red_icon-icons.com_54903.png",icone:"https://cdn-icons-png.flaticon.com/512/1254/1254256.png" },
                              {tipo: "√Årea de posicionamento de ve√≠culos (pol√≠gono)", url: "caminh√£o.png",icone: "https://cdn-icons-png.flaticon.com/512/8397/8397505.png"},                               
                              {tipo: "Tanque de armazenamento (ponto)", url: "TanqueArmazenamento.jpg",icone: "https://cdn-icons-png.flaticon.com/512/5755/5755651.png"},
                              {tipo: "Silo (ponto)", url: "silo.png",icone: "https://cdn-icons-png.flaticon.com/512/2078/2078261.png"},
                              {tipo: "√Årea de controle de carga solta (pol√≠gono)", url: "cargaSolta.png",icone: "https://cdn-icons-png.flaticon.com/512/4829/4829649.png"},
                              {tipo: "Port√™iner Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                              {tipo: "Port√™iner, Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},

                              //{tipo: "", url: ".png"},
                                //{tipo: "", url: ".png"},                                                                                                

                            ]
          return arrayIcones                  
       }

        function getIcone(icone,azimute) {

            let arrayIcones = getArrayIcones();
            let retorno = 'https://cdn-icons-png.flaticon.com/512/7199/7199765.png';
           
            for (let i = 0; i < arrayIcones.length; i++) {
           
              if (arrayIcones[i].tipo === icone) {
                  retorno = arrayIcones[i].icone
                  
                  break;
              }           
            }
            //Se for c√¢mera e n√£o h√° azimute, entendemos ser c√¢mera dome
            //Retornar endere√ßo do √≠cone de uma dome  
            if(icone.search('C√¢mera')>=0 && !azimute)
               retorno = 'https://cdn-icons-png.flaticon.com/512/10005/10005664.png';
            return retorno;   
       }

        function getPrimeiraOcorrencia(coord) {

           let vetor = coord.split( ' - ')


           return vetor[0]

       }
        // Fun√ß√£o que desenha gr√°fico de azimute em canvas

        function gerarGraficoAzimute(azimute) {
          const canvas = document.createElement("canvas");
          canvas.width = 220;
          canvas.height = 220;
          const ctx = canvas.getContext("2d");

          // fundo
          ctx.fillStyle = "#f9f9f9";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // c√≠rculo da b√∫ssola
          ctx.beginPath();
          ctx.arc(110, 110, 80, 0, 2 * Math.PI);
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          ctx.stroke();

          // √¢ngulos de 45 em 45 graus
          ctx.fillStyle = "black";
          ctx.font = "bold 8px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          for (let angle = 0; angle < 360; angle += 45) {
            const rad = (angle - 90) * Math.PI / 180;
            const x = 110 + 70 * Math.cos(rad);
            const y = 110 + 70 * Math.sin(rad);
            ctx.fillText(angle + "¬∞", x, y);
          }

          // dire√ß√µes principais N, S, L, O em azul, fora do c√≠rculo
          ctx.fillStyle = "blue";
          ctx.font = "bold 14px Arial";

          const offset = 95; // raio maior para jogar as letras para fora

          // Norte (0¬∞)
          ctx.fillText("N", 110, 110 - offset);
          // Sul (180¬∞)
          ctx.fillText("S", 110, 110 + offset);
          // Leste (90¬∞)
          ctx.fillText("L", 110 + offset, 110);
          // Oeste (270¬∞)
          ctx.fillText("O", 110 - offset, 110);

          // desenhar linha do azimute
          const radAz = (azimute - 90) * Math.PI / 180;
          const xAz = 110 + 70 * Math.cos(radAz);
          const yAz = 110 + 70 * Math.sin(radAz);

          ctx.beginPath();
          ctx.moveTo(110, 110);
          ctx.lineTo(xAz, yAz);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.stroke();

          return canvas;
        }

      
  
      // Fun√ß√£o para calcular azimute em rela√ß√£o ao norte verdadeiro
        function calcularAzimute(lat1, lon1, lat2, lon2) {
          // Converter graus para radianos
          const toRad = deg => deg * Math.PI / 180;
          const toDeg = rad => rad * 180 / Math.PI;

          const dLon = toRad(lon2 - lon1);
          const lat1Rad = toRad(lat1);
          const lat2Rad = toRad(lat2);

          // F√≥rmula de azimute (bearing)
          let y = Math.sin(dLon) * Math.cos(lat2Rad);
          let x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                  Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

          let brng = toDeg(Math.atan2(y, x));
          return (brng + 360) % 360; // normalizar para 0‚Äì360¬∞
        }

        // Fun√ß√£o que calcula o cone e retorna o array de coordenadas
        function calcularCone(lat, lon, azimute, abertura, altura) {
          var rad = azimute * Math.PI / 180;
          var half = abertura / 2 * Math.PI / 180;

          var lat1 = lat + altura * Math.cos(rad - half);
          var lon1 = lon + altura * Math.sin(rad - half);

          var lat2 = lat + altura * Math.cos(rad + half);
          var lon2 = lon + altura * Math.sin(rad + half);

          // retorna o array de pontos do tri√¢ngulo
          return [[lat, lon], [lat1, lon1], [lat2, lon2]];
        }
       
        function getCoordenada(coordenada) {
             
          if(typeof coordenada === 'string') coordenada = parseFloat(coordenada)
          return coordenada;
        }
 
        function contarRecintos(pontos) {
            let contador = 0;
            for (let ix = 0; ix < pontos.length; ix++) {
              if (pontos[ix].Tipo && pontos[ix].Tipo.search('Recinto') !== -1) {
                contador++;
              }
            }
            return contador;
        }
        function setPontos(pontos){
            pontos = pontos;
        }  

        function plotarPontosMapa(pontos) {
          if(isTracing) console.log('plotarPontosMapa',pontos);

    
 
            // √çcones da web
            arrayIcones = []
 
   
            //Conta quantos Recintos h√° em pontos
            let qtdRecintos = contarRecintos(pontos);   
                            
            //Percorre a tabela de ativos                          
            for (let ix = 0; ix < pontos.length; ix++) {  
          
              let p = pontos[ix]
              
              if(p.Ativo != 'true') continue

              //Validar se √© ponto ou √°rea
              //Ponto n√£o pode ter pol√≠gono no p.Tipo
              let iconURL = getIcone(p.Tipo,p.Azimute)

              const customIcon = L.icon({
                iconUrl: iconURL,
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
                });
                  
              latitude  = ''
              longitude = ''

              if(p.Tipo.search('pol√≠gono') >=0) {
          

                  let arrayLatitude = p.Latitude.split(' - ')
                  let arrayLongitude = p.Longitude.split(' - ')

                  let ultimaLatitude  = getCoordenada(arrayLatitude[0]); 
                  let UltimaLongitude = getCoordenada(arrayLongitude[0]) ;         
                  for (let lx = 0; lx < arrayLatitude.length; lx++) {  

                      if (p.Tipo.search('Recinto')>=0) { 
                          poligonoRecinto.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoRecinto.push([ultimaLatitude, UltimaLongitude]);
                          }
                      }

                      areas.forEach(area => {
                     
                          if (p.Tipo.toLocaleLowerCase().search(area.titulo.toLocaleLowerCase()) >= 0) {
                            area.coords.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          }
                      });  
                    /*
                      if (p.Tipo.search('ve√≠culos')>=0) { 
                          
                          poligonoAreaVeiculo.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoAreaVeiculo.push([ultimaLatitude, UltimaLongitude]);                        
                            poligonoAreaVeiculo.push([getCoordenada(arrayLatitude[0]) , getCoordenada(arrayLongitude[0])]);
                          }                        

                      }                       
                      if (p.Tipo.search('lotes')>=0){ 
                        poligonoAreaLote.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoAreaLote.push([ultimaLatitude, UltimaLongitude]);                        
                            
                          }                     
              
                      }                          
                      if (p.Tipo.search('confer√™ncia f√≠sica')>=0) { 
                    
                        poligonoConferencia.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoConferencia.push([ultimaLatitude, UltimaLongitude]);                        
                            
                          }                       
    
                      }                                           
                      if (p.Tipo.search('cont√™ineres')>=0) {                 
                          poligonoAreaConteiner.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoAreaConteiner.push([ultimaLatitude, UltimaLongitude]);                        
                            
                          }

                      }                                         
                            
                      if (p.Tipo.search('carga solta')>=0) { 
                          poligonoAreaCargaSolta.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoAreaCargaSolta.push([ultimaLatitude, UltimaLongitude]);                        
                            
                          }                      

                      }                                             
                          
                      if (p.Tipo.search('Port√™iner')>=0) { 
                      
                        poligonoPorteiner.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoPorteiner.push([ultimaLatitude, UltimaLongitude]);                        
                            
                          }                         
                                                
                      }     
*/
                  }

              } 
              if(p.Tipo.search('ponto') >=0) {
                  if(p.Latitude === '') continue; 
                  latitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)));
                  longitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)));
                  let azimute = p.Azimute ? p.Azimute : 0.

                  //Marco Zero - Recinto
                  if(qtdRecintos===1) {
                      // Define o t√≠tulo da p√°gina
                      document.getElementById("map-title").innerHTML = p.Equipamento; 
                  }
                    if(p.Tipo.search('Recinto')>=0) {
                     
                      //var markers = L.markerClusterGroup();
                      var markers = L.markerClusterGroup();
                      markers.addLayer(L.marker([latitude, longitude]).//bindPopup(p.Equipamento));
                      bindPopup("<strong style='color:blue;'>" + p.Equipamento + "</strong>"));

                      map.addLayer(markers);
                      continue;

                    }   
                  //Se for c√¢mera e houver azimute
                  if(p.Tipo.search('C√¢mera') >=0 && p.Azimute ){
                      // Usa a fun√ß√£o para obter coordenadas e desenhar no mapa
                        var coordsCone = calcularCone(latitude, longitude, azimute, 40, 0.0005);
                        /*
                    Op√ß√µes principais
                    color: cor da borda.
                    weight: espessura da borda.
                    dashArray: define se a linha √© cont√≠nua ou tracejada. Exemplo: "10, 5" (10px tra√ßo, 5px espa√ßo).
                    fillColor: cor interna do pol√≠gono.
                    fillOpacity: opacidade do preenchimento (0 = transparente, 1 = opaco).
                    opacity: opacidade da linha de contorno.
                        */
                    L.polygon(coordsCone, {
                      color: 'blue',        // cor da linha
                      weight: 1,            // espessura da linha
                      dashArray: '5, 5',    // tra√ßos e espa√ßos (5px tra√ßo, 5px espa√ßo)
                      fillColor: 'blue',    // cor de preenchimento
                      fillOpacity: 0.09      // opacidade do preenchimento
                    }).addTo(map);



                  }
                  // Marker com popup contendo texto + gr√°fico
                  
                  let marker = L.marker([latitude, longitude], { icon: customIcon })
                    .bindPopup(() => {
                      // conte√∫do textual
                      const div = document.createElement("div");
                      
                      div.innerHTML = `
                        <strong style="color: blue;">${p.Tipo}</strong>
                          <ul style="padding-left: 15px; margin: 0;">
                            <li>${p.Equipamento}</li>
                            <li>Latitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)))}</li>
                            <li>Longitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)))}</li>

                            ${p.Azimute ? `<li>Azimute: ${p.Azimute}</li>` : ""}
                          </ul>
                      
                      `;

                      if (p.Azimute) {
                        div.appendChild(gerarGraficoAzimute(p.Azimute));
                      }
                      return div;
                    });

                  markersCluster.addLayer(marker);
                
               }
            }
             
            if(markersCluster) map.addLayer(markersCluster);

            const marcadorVermelho = L.icon({
              iconUrl: 'https://cdn-icons-png.flaticon.com/128/1397/1397898.png',
              shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            });

              // Adiciona marcador na primeira coordenada
            if(poligonoRecinto.length >0) {  
                  const primeiraCoord = poligonoRecinto[0]; // pega o primeiro ponto
                    // Pol√≠gono do Recinto
                    L.polyline(poligonoRecinto, {
                      color: rodapeInfo[1].cor,
                      weight: 4,
                      opacity: 0.8
                    }).addTo(map)
                      .bindTooltip("<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' style='vertical-align:middle;margin-right:5px;'/>" +
                                      "<strong style='color:darkred;'>Pol√≠gono do Recinto</strong>",
                      {
                        permanent: false,
                        direction: "center",
                        className: "tooltip-transparent"
                      });
                   L.marker(primeiraCoord, { icon: marcadorVermelho })
                      .addTo(map)
                      .bindPopup(
                        "<strong style='color:darkred;'>Marco 0 do Recinto</strong>",
                        { className: 'popup-transparente' }
                      );


              }  

              areas.forEach(area => {
                if (area.coords.length >= 1) {
                  //const info = getRodapeInfo(area.titulo);
                  const primeiraCoord = area.coords[0]; // pega o primeiro ponto
                  L.polygon(area.coords, {color: area.cor})
                    .addTo(map)

                    .bindTooltip("<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' style='vertical-align:middle;margin-right:5px;'/>" +
                              "<strong style='color:darkred;'>"+area.titulo+"</strong>",                    
                    { 
                                 permanent: false, 
                                 direction: "top" , // centralizado
                                 className: "polygon-label" // opcional para estilizar via CSS
                                              })
                    
                    .openTooltip();

                    L.marker(primeiraCoord, { icon: marcadorVermelho })
                      .addTo(map)
                      .bindPopup(
                        "<strong style='color:darkred;'>"+area.titulo+"</strong>",
                        { className: 'popup-transparente' }
                      );
                }
              });                            

            //Abre os pontos de um cluster
            if(markersCluster)
                markersCluster.on('clusterclick', function (a) {
                  a.layer.spiderfy(); // abre o cluster
                  a.originalEvent.preventDefault(); // evita comportamento padr√£o
                });

            if(markersCluster)
               markersCluster.on('clusteringend', function () {
                    markersCluster.getLayers().forEach(layer => {
                      if (layer.spiderfy) layer.spiderfy();
                    });
                  });

            // Ajusta o zoom para mostrar tudo
     
            if(!markersCluster.getBounds().isValid()) {
              var bounds = L.latLngBounds([[-15.78, -47.93], [-15.75, -47.90]]);
              
              map.fitBounds(bounds);  
              map.setZoom(6);    
            } else 
            if(markersCluster)
               map.fitBounds(markersCluster.getBounds(), { padding: [30, 30] });
        }
 

</script> 

</body>
</html>