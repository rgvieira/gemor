<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="utf-8" />
    <title>Mapa de Recinto Alfandegado</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="icone.png">
    <!-- Leaflet CSS 
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.css">   
     
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <!-- MarkerCluster CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/MarkerCluster.Default.min.css" />
  <style>
  :root {
    --azul: #2196F3;
    --azul-escuro: #0D47A1;
    --cinza-claro: #f1f1f1;
    --fonte: Arial, sans-serif;
  }

  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family: var(--fonte);
  }


  /* ===============================
    MAPA E √çCONES FIXOS
  =============================== */
  #map {
    height: 100%;
    width: 100%;
    position: relative;
  }

  #flaticon-icon {
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 10000;
  }
  #flaticon-icon img {
    width: 32px;
    height: 32px;
  }

  #map-title {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: transparent;
    padding: 5px 15px;
    border-radius: 5px;
    font-weight: bold;
    font-size: 1.8rem;
    color: var(--azul);
    z-index: 1000;
  }

  /* ===============================
    RODAP√â
  =============================== */
  .map-footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: transparent;
    padding: 6px 10px;
    font-size: 0.7rem;
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    z-index: 1000;
  }
  .map-footer-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .map-footer-item img {
    height: 20px;
  }

  /* ===============================
    PAINEL LATERAL  height: 900px,
  =============================== */
 .painel-tabela {
  position: absolute;
  top: 50px;
  right: 10px;
  width: 60%;
  height: 700px !important;


  background: #fff;
  border: 2px solid var(--azul-escuro);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  overflow: auto; /* mant√©m rolagem vertical e horizontal */
  display: none;
  z-index: 1000;
  padding: 10px;
  font-size: 0.5rem;
  min-width: 900px;
}
  .painel-tabela .fechar {
    float: right;
    cursor: pointer;
    font-weight: bold;
    color: darkred;
    margin-bottom: 10px;
  }
  .painel-tabela h2 {
    margin: 0 0 8px 0;
    font-size: 0.8rem;
    color: var(--azul-escuro);
  }
  .painel-tabela .table-wrapper {
    overflow-x: auto; /* for√ßa rolagem horizontal */
    overflow-y: auto; /* for√ßa rolagem vertical */
    max-height: none; /* n√£o limita altura */
    border: 1px solid #ddd;
  }

  /* ===============================
    TABELA
  =============================== */
  .painel-tabela table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; /* for√ßa caber na largura */
    font-size: 0.65rem;  /* fonte menor */
  }

  .painel-tabela th,
  .painel-tabela td {
    padding: 2px 4px;
    border: 1px solid #ddd;
    text-align: center;
    white-space: normal; /* permite quebra */
    word-wrap: break-word;
  }
  .painel-tabela thead {
    background: var(--cinza-claro);
    color: #000;
    font-weight: bold;
    position: sticky;
    top: 0;
    z-index: 2;
  }
  .painel-tabela tbody tr:nth-child(even) {
    background: #f9f9f9;
  }
  .painel-tabela tbody tr:hover {
    background: #e3f2fd;
  }

  /* Colunas fixas */
  .painel-tabela table th:nth-child(1),
  .painel-tabela table td:nth-child(1) { width: 35px; }
  .painel-tabela table th:nth-child(2),
  .painel-tabela table td:nth-child(2) { width: 50px; }
  .painel-tabela table th:nth-child(3),
  .painel-tabela table td:nth-child(3) { width: 20px; }
  .painel-tabela table th:nth-child(4),
  .painel-tabela table td:nth-child(4) { width: 35px; }
  .painel-tabela table th:nth-child(5),
  .painel-tabela table td:nth-child(5) { width: 20px; }
  .painel-tabela table th:nth-child(6),
  .painel-tabela table td:nth-child(6) { width: 80px; }
  .painel-tabela table th:nth-child(7),
  .painel-tabela table td:nth-child(7) { width: 90px; }
  .painel-tabela table th:nth-child(8),
  .painel-tabela table td:nth-child(8) { width: 80px; }
  /* üì± Mobile */
  @media (max-width: 768px) {
    .painel-tabela {
      top: 0;
      right: 0;
      width: 100%;
      height: 100vh; /* ocupa toda a tela */
      min-width: unset; /* remove largura m√≠nima */
      font-size: 0.7rem;
      border-radius: 0; /* painel colado nas bordas */
    }

    .painel-tabela table {
      min-width: 600px; /* for√ßa scroll horizontal */
      font-size: 0.65rem;
    }

    .painel-tabela th,
    .painel-tabela td {
      padding: 2px 4px;
      font-size: 0.65rem;
    }

    .dataTable-pagination .dataTable-pagination-button {
      font-size: 0.55rem;
      padding: 1px 4px;
    }
  }
  /* ===============================
    BOT√ïES
  =============================== */

  .btn-acao,
  .btn-plotar,
  .btn-editar {
    background: linear-gradient(180deg, #2196F3, #1565C0);
    border: 1px solid #0D47A1;
    border-radius: 4px;
    color: #fff;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 0.7rem;
    box-shadow: 0 2px #0D47A1;
    margin-right: 6px;
  }
  .btn-fechar {
    background: transparent;   /* sem fundo */
    border: none;              /* sem borda */
    padding: 4px;
    cursor: pointer;
  }

  .btn-fechar:hover {
    background: #f5f5f5;       /* leve destaque ao passar o mouse */
    border-radius: 4px;
  }

  .icon-fechar {
    width: 20px;
    height: 20px;
    display: block;
  }

  .btn-acao:active,
  .btn-plotar:active,
  .btn-editar:active {
    box-shadow: 0 1px #0D47A1;
    transform: translateY(1px);
  }

  /* Estilo do alerta */
  .alert-box {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #fff;          /* fundo branco */
    color: #d32f2f;            /* texto vermelho */
    padding: 12px 20px;
    border-radius: 6px;
    font-size: 16px;
    font-weight: bold;
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 9999;
    border: 2px solid #d32f2f; /* borda vermelha opcional */
  }

  .alert-box.show {
    opacity: 1;
  }

  .alert-box.alert-error {
    /* se quiser diferenciar erros, pode refor√ßar borda ou sombra */
    box-shadow: 0 0 10px #d32f2f;
  }

  /* Remove o X do campo de busca */
  input[type="search"]::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
  }

  /* Campo de busca em azul */
  .dataTable-input {
    padding: 2px 3px;
    border: 1px solid #2196f3; /* azul */
    border-radius: 4px;
    font-size: 10px;
    outline: none;
    transition: all 0.3s ease;
  }

  .dataTable-input:focus {
    border-color: #0d47a1;
    box-shadow: 0 0 6px rgba(33, 150, 243, 0.5);
  }

  /* Remove o X do campo de busca */
  .dataTable-input::-webkit-search-cancel-button {
    -webkit-appearance: none;
    appearance: none;
  }

  /* Bot√µes de pagina√ß√£o */
  .dataTable-pagination .dataTable-pagination-button {
    background: #2196f3; /* azul */
    color: white;
    border: none;
  font-size: 0.65rem;
  padding: 1px 4px;
    margin: 1px;
    border-radius: 2px;
    cursor: pointer;
    transition: background 0.3s ease;
  }

  .dataTable-pagination .dataTable-pagination-button:hover {
    background: #1976d2; /* azul mais escuro */
  }

  .dataTable-pagination .dataTable-pagination-button.active {
    background: #0d47a1; /* azul ainda mais escuro */
    font-weight: bold;
  }


  /* ===============================
    LABELS E POPUPS
  =============================== */
  .polygon-label {
    font-weight: bold;
    font-size: 0.65rem;
    color: #000;
    background: transparent;
    border: none;
    box-shadow: none;
  }
  .popup-transparente .leaflet-popup-content-wrapper,
  .popup-transparente .leaflet-popup-tip {
    background: transparent;
    box-shadow: none;
    border: none;
  }
  .popup-table {
    max-height: 300px;
    overflow: auto;
  }
  .text-label {
    font-size: 0.9rem;
    font-weight: bold;
    color: darkblue;
    background: rgba(255,255,255,0.7);
    padding: 2px 6px;
    border-radius: 4px;
  }
  .tooltip-transparent {
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    color: var(--azul);
    font-weight: bold;
  }

  /* ===============================
    UPLOAD
  =============================== */
  #uploadIcon {
    position: fixed;
    top: 20px;
    right: 20px;
    cursor: pointer;
    text-align: center;
  }
  #uploadIcon svg {
    width: 32px;
    height: 32px;
    fill: var(--azul);
  }
  #fileCSV { display: none; }

  .leaflet-control-custom,
  .leaflet-control-upload {
    background: #fff;
    border-radius: 4px;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
  }
  .leaflet-control-custom {
    font-size: 1.2rem;
    padding: 5px;
  }
  .leaflet-control-upload {
    padding: 4px;
  }
  .leaflet-control-upload svg {
    width: 28px;
    height: 28px;
    fill: var(--azul);
  }

  /* ===============================
    POPUP TRANSPARENTE
  =============================== */
  .leaflet-popup-content-wrapper {
    background: rgba(255,255,255,0.75);
    box-shadow: none;
    border: none;
  }

  </style>
</head>

<body>
  <p id="siglaRecinto"></p>

  <input type="file" id="fileCSV" accept=".csv,text/csv">

  <div id="map">
      <div id="flaticon-icon">
        <a href="https://www.flaticon.com/br/" title="Flaticon" target="_blank">
          <img 
            src="https://www.flaticon.com/media/img/flaticon-logo.svg"
            alt="Flaticon logo">
        </a>

      </div>

  </div>
  <div id="map-title"></div>

  <div id="painelTabela" class="painel-tabela" style="display:none;
      position:absolute; top:50px; right:10px; width:400px; height:300px;
      background:#fff; border:1px solid #ccc; overflow:auto; z-index:9999;">
    <button onclick="fecharPainel()" class="btn-acao btn-fechar" title="Fechar" style="float:right; margin:5px;">
      <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
          alt="Fechar" class="icon-fechar" style="width:20px;height:20px;">
    </button>
    <div class="table-wrapper"></div>
  </div>


  <!-- Leaflet JS 
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
  -->

  <script src="https://cdn.jsdelivr.net/npm/vanilla-datatables@latest/dist/vanilla-dataTables.min.js"></script>

   
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <!-- MarkerCluster JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.3/leaflet.markercluster.min.js"></script>
  <script>
    //Vari√°veis e constantes globais
    let idDataTable = null; // vari√°vel global
    let linhaReferencia = null; // guarda √≠ndice da √∫ltima linha clicada

    const nivelZoom = 18;

    // Array para armazenar coordenadas das casas
    let poligonoRecinto = []; 
      
    // JSON com array de 5 itens
    const rodapeInfo = [
      { titulo: "√Årea:", icone: "", cor: 'navy' },                   
      { titulo: "Recinto", icone: "", cor: 'navy' },
                        ];    
    const areas = [
      { coords: [], titulo: "Posicionamento de Ve√≠culo", cor: 'darkcyan' },
      { coords: [], titulo: "Armazenamento de Lotes", cor: 'green' },
      { coords: [], titulo: "Controle de Carga Solta", cor: 'purple' },
      { coords: [], titulo: "Posicionamento de Cont√™iner",cor: 'red' },
      { coords: [], titulo: "Confer√™ncia F√≠sica", cor: 'orange' },
      { coords: [], titulo: "Port√™iner, Shiploader ou similares", cor: 'black' },
      { coords: [], titulo: "Port√™iner Shiploader ou similares", cor: 'black' }          
                        ];   

    // Estado da fun√ß√£o de inibir apresenta√ß√£o de coordenadas no mapa
    let clickEnabled = false;
    isTracing = false; //Mostra dados na console
    // Grupo de clusters
    let markersCluster ;
    let tabelaGeo = [{Tipo: "", Equipamento: "", Azimute: 0, Longitude: 0, Latitude: 0}
                  ];      
        
            
      // Mapas base gratuitos
      const baseMaps = {
        "OpenStreetMap": L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "¬© OpenStreetMap"
        }),
        "Carto Light": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}{r}.png", {
          attribution: "¬© Carto"
        }),
        "Carto Dark": L.tileLayer("https://cartodb-basemaps-a.global.ssl.fastly.net/dark_all/{z}/{x}/{y}{r}.png", {
          attribution: "¬© Carto"
        }),
        "Esri World": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}", {
          attribution: "Tiles ¬© Esri"
        }),
        // ‚úÖ Sat√©lite Esri
        "Esri Satellite": L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
          attribution: "Tiles ¬© Esri & the GIS community"
        })
      };

      // √çcones ideais para cada mapa
      const baseMapIcons = {
        "OpenStreetMap": "üó∫Ô∏è",       // mapa gen√©rico
        "Carto Light": "üåû",          // estilo claro
        "Carto Dark": "üåô",           // estilo escuro
        "Esri World": "üåç",           // mapa de ruas/mundo
        "Esri Satellite": "üõ∞Ô∏è"       // sat√©lite
      };  

    //Mapa
    let map;

    // Controle customizado
    let popupAberto = false;
    let popupRef = null;
  
    initMapa();
    plotartabelaGeoMapa(tabelaGeo);
    

    function gerarTabelaHTML(tabela) {
      if (!tabela || tabela.length === 0 || tabela[0].Tipo === '') {
        return "";
      }

      // Utilit√°rio para evitar quebra de HTML ao inserir strings
      const esc = s => String(s || "").replace(/'/g, "&#39;").replace(/"/g, "&quot;");

      let html = `
        <!-- Bot√µes no topo -->
        <div class="tabela-actions" style="margin-bottom:8px;">
          <button onclick="criarLinha()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/1665/1665680.png" 
                alt="Nova linha" style="width:12px;height:12px;">
          </button>            
          <button onclick="baixarCSV()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/12809/12809885.png" 
                alt="Salvar csv" style="width:12px;height:12px;">
          </button>
          <button onclick="fecharPainel()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
                alt="Fechar" class="icon-fechar" style="width:12px;height:12px;">
          </button> 
        </div>

        <table id="containerTabelaGeo">
          <thead>
            <tr>
              <th>Tipo</th>
              <th>Equipamento</th>
              <th>Ativo</th>              
              <th>Protocolo</th>
              <th>Azimute</th>
              <th>Latitude</th>
              <th>Longitude</th>
              <th>Plotar</th> 
              <th>Editar</th>
            </tr>
          </thead>
          <tbody>
      `;

      tabela.forEach((p, idx) => {
        const azimute = p.Azimute ? p.Azimute : 0.;
        const tipo = p.Tipo || "";
        const protocoloCompleto = p.Protocolo || "";
        const protocoloCurto = protocoloCompleto.slice(-6);

        const latCompleta = p.Latitude || "";
        const latCurta = latCompleta.slice(-10); // 10 caracteres

        const lonCompleta = p.Longitude || "";
        const lonCurta = lonCompleta.slice(-10); // 10 caracteres

        // Equipamento: remover todas as ocorr√™ncias de Tipo (case-insensitive)
        const equipamentoCompleto = p.Equipamento || "";
        const eqCurtoCalc = (() => {
          if (!tipo) return equipamentoCompleto;
          const re = new RegExp(tipo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi'); // escape + case-insensitive
          const removido = equipamentoCompleto.replace(re, '').trim();
          if (removido) return removido;
          // fallback: se ficou vazio, mostra uma vers√£o curta √∫til
          return equipamentoCompleto.length > 10 ? equipamentoCompleto.slice(-10) : equipamentoCompleto;
        })();

        html += `
          <tr data-index="${idx}">
            <td>${esc(tipo)}</td>
            <td onclick="mostrarEquipamento(this, '${esc(equipamentoCompleto)}', '${esc(tipo)}')"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(eqCurtoCalc)}
            </td>
            <td contenteditable="true" onblur="tabelaGeo[${idx}].Ativo=this.innerText">${esc(p.Ativo)}</td>
            <td onclick="mostrarProtocolo(this, '${esc(protocoloCompleto)}')"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(protocoloCurto)}
            </td>
            <td contenteditable="true" onblur="tabelaGeo[${idx}].Azimute=this.innerText">${esc(p.Azimute)}</td>
            <td onclick="mostrarLatLon(this, '${esc(latCompleta)}', 10)"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(latCurta)}
            </td>
            <td onclick="mostrarLatLon(this, '${esc(lonCompleta)}', 10)"
                style="cursor:pointer;"
                title="Clique para ver completo">
              ${esc(lonCurta)}
            </td>
            <td style="text-align:left;">
              <button onclick="plotarNoMapa('${esc(p.Latitude)}', '${esc(p.Longitude)}', '${esc(p.Tipo)}', '${esc(p.Equipamento)}', ${azimute}, ${idx})" class="btn-acao btn-fechar">üìç</button>
            </td>
            <td style="text-align:left;">
              <button onclick="editarLinha(${idx})" class="btn-acao btn-fechar" title="Editar linha">‚úèÔ∏è</button>
            </td>
          </tr>
        `;
      });

      html += `</tbody></table>`;

      // Bot√µes no rodap√©
      html += `
        <div class="tabela-actions" style="margin-top:8px;">
          <button onclick="criarLinha()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/1665/1665680.png" 
                alt="Nova linha" style="width:20px;height:20px;">
          </button>            
          <button onclick="baixarCSV()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/512/12809/12809885.png" 
                alt="Salvar csv" style="width:20px;height:20px;">
          </button>
          <button onclick="fecharPainel()" class="btn-acao btn-fechar">
            <img src="https://cdn-icons-png.flaticon.com/128/4034/4034637.png" 
                alt="Fechar" class="icon-fechar">
          </button>           
        </div>
      `;

      return html;
    }
    function mostrarProtocolo(td, valorCompleto) {
      td.innerText = (td.innerText === valorCompleto)
        ? valorCompleto.slice(-6)
        : valorCompleto;
    }

    function mostrarLatLon(td, valorCompleto, n = 10) {
      td.innerText = (td.innerText === valorCompleto)
        ? valorCompleto.slice(-n)
        : valorCompleto;
    }

    function mostrarEquipamento(td, valorCompleto, tipo) {
      const curto = (() => {
        if (!tipo) return valorCompleto;
        const re = new RegExp(tipo.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        const removido = valorCompleto.replace(re, '').trim();
        if (removido) return removido;
        return valorCompleto.length > 10 ? valorCompleto.slice(-10) : valorCompleto;
      })();

      td.innerText = (td.innerText === valorCompleto)
        ? curto
        : valorCompleto;
    }

      function fecharPainel() {
        limparBusca();
        const painel = document.getElementById("painelTabela");
        if (painel) painel.style.display = "none";
      }

      function editarLinha(index) {
        const tabela = document.querySelector("#containerTabelaGeo");
        if (!tabela) {
          console.error("Tabela n√£o encontrada");
          return;
        }

        // Seleciona a linha pelo data-index
        const row = tabela.querySelector(`tbody tr[data-index="${index}"]`);
        if (!row) {
          console.error("Linha n√£o encontrada para √≠ndice:", index);
          return;
    }

        const cells = row.querySelectorAll("td");

        // Torna todas as c√©lulas (exceto Plotar e Editar) edit√°veis
        for (let i = 0; i < cells.length - 2; i++) {
          cells[i].setAttribute("contenteditable", "true");
          cells[i].style.backgroundColor = "#ffffcc"; // destaque amarelo
          cells[i].style.textAlign = "left";          // üëâ alinhamento √† esquerda
        }

        // Troca bot√£o para salvar
        const btnEditar = cells[cells.length - 1].querySelector("button");
        if (btnEditar) {
          btnEditar.innerText = "üíæ";
          btnEditar.onclick = function() { salvarLinha(index); };
        }
      }

      function mostrarAlerta(mensagem) {
        const alerta = document.createElement("div");
        alerta.className = "alert-box";

        // Se come√ßar com "Erro", adiciona √≠cone ‚ö†Ô∏è
        if (mensagem.trim().toLowerCase().startsWith("erro")) {
          alerta.innerHTML = `‚ö†Ô∏è ${mensagem}`;
        } else {
          alerta.textContent = mensagem;
        }

        document.body.appendChild(alerta);

        setTimeout(() => alerta.classList.add("show"), 10);

        setTimeout(() => {
          alerta.classList.remove("show");
          setTimeout(() => alerta.remove(), 300);
        }, 3000);
      }

      // Fun√ß√£o para salvar linha editada
      function salvarLinha(index) {
        const tabela = document.querySelector("#containerTabelaGeo");
        const row = tabela.querySelector(`tbody tr[data-index="${index}"]`);
        if (!row) return;

        const cells = row.querySelectorAll("td");
        const campos = ["Tipo","Equipamento","Ativo","Protocolo","Azimute","Latitude","Longitude"];

        // Normaliza leitura do Tipo uma √∫nica vez
        const tipoTexto = (cells[0]?.textContent || "").trim().toLowerCase();
        const tipoAtual = removerAcentos(tipoTexto); // "poligono" ou "ponto"
        const separador = ";";

        for (let i = 0; i < campos.length; i++) {
          let valor = (cells[i]?.textContent || "").trim();

          // Valida√ß√µes b√°sicas (mantidas)
          if (["Tipo","Equipamento","Ativo","Latitude","Longitude"].includes(campos[i]) && valor === "") {
            mostrarAlerta(`${campos[i]} n√£o pode estar em branco. Latitude/Longitude, separar por ";" `);
            return;
          }
          if (campos[i] === "Tipo") {
            const tipoVal = (valor.toLowerCase());
      
               if (campos[i] === "Tipo") {
                  const tipoVal = valor
                    .normalize("NFD")                // remove acentos
                    .replace(/[\u0300-\u036f]/g, "")
                    .toLowerCase();

                  if (!tipoVal.includes("ponto") && !tipoVal.includes("poligono")) {
                    mostrarAlerta("Tipo deve conter 'ponto' ou 'pol√≠gono'.");
                    return;
                  }
                }
          }
          if (campos[i] === "Ativo") {
            const ativoVal = valor.toLowerCase();
            if (ativoVal !== "true" && ativoVal !== "false") {
              mostrarAlerta("Ativo deve ser 'true' ou 'false'.");
              return;
            }

            cells[i].textContent = valor.toLocaleLowerCase();
            // Atualiza tabelaGeo com o valor j√° tratado
            if (!tabelaGeo[index]) tabelaGeo[index] = {};
               tabelaGeo[index][campos[i]] = valor.toLocaleLowerCase();
          }

          // Regras espec√≠ficas para pol√≠gono em Latitude/Longitude
          if (tipoAtual.search("poligono") >= 0 && ["Latitude","Longitude"].includes(campos[i])) {
            // Aceitar diversos tipos de ‚Äúpontos e v√≠rgulas‚Äù e normalizar espa√ßos
 
            const temSeparador = valor.search(separador) >=0; // ; normal ou fullwidth
            /*
            if (!temSeparador) {
              
              mostrarAlerta(`Erro: Para 'pol√≠gono', todos os valores em ${campos[i]} devem estar separados por [${separador}]. Exemplo: -20.322454; -20.322303 ; -20.322223.`);
              return;
            }
      */
            // Normaliza: m√∫ltiplos espa√ßos ‚âà 1 espa√ßo, troca todo ; por " - "
            valor = valor
              .replace(/\s+/g, " ")           // colapsa espa√ßos
              .replace(/[;Ôºõ]+/g, " - ");     // troca todas as varia√ß√µes de ; por " - "

            // Atualiza a c√©lula vis√≠vel imediatamente
            cells[i].textContent = valor;
          }

          // Atualiza tabelaGeo com o valor j√° tratado
          if (!tabelaGeo[index]) tabelaGeo[index] = {};
          tabelaGeo[index][campos[i]] = valor;
        }

        // Finaliza modo de edi√ß√£o
        for (let i = 0; i < cells.length - 2; i++) {
          cells[i].removeAttribute("contenteditable");
          cells[i].style.backgroundColor = "";
          cells[i].style.textAlign = "left";
        }

        // Restaura bot√£o
        const btnEditar = cells[cells.length - 1].querySelector("button");
        if (btnEditar) {
          btnEditar.innerText = "‚úèÔ∏è";
          btnEditar.onclick = function() { editarLinha(index); };
        }
      

        console.log("Linha salva:", tabelaGeo[index]);
      }

      // Helper para normalizar acentos (ex.: "pol√≠gono" -> "poligono")
      function removerAcentos(str) {
        return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      }

      // Fun√ß√£o para criar nova linha
      function criarLinha() {
        const tabelaBody = document.querySelector("#containerTabelaGeo tbody");

        // Objeto padr√£o para nova linha
        const novaLinha = {
          Tipo: "ZZZZZZZ (ponto) ou (pol√≠gono)",
          Equipamento: "",
          Ativo: "true",
          Protocolo: "",
          Azimute: "",
          Latitude: "",
          Longitude: ""
        };

        // Adiciona ao array global
        tabelaGeo.push(novaLinha);

        // Regera tabela completa
        const wrapper = document.querySelector(".table-wrapper");
        wrapper.innerHTML = gerarTabelaHTML(tabelaGeo);

        // Pega √≠ndice da √∫ltima linha
        const ultimoIndex = tabelaGeo.length - 1;

        // Habilita edi√ß√£o autom√°tica na √∫ltima linha
        editarLinha(ultimoIndex);

        // Faz scroll at√© a √∫ltima linha
        const tabela = document.querySelector("#containerTabelaGeo");
        const ultimaLinha = tabela.rows[ultimoIndex + 1]; // +1 porque cabe√ßalho √© linha 0
        ultimaLinha.scrollIntoView({ behavior: "smooth", block: "center" });
      }

      function limparBusca() {
        if (idDataTable) {
    // üëâ Resetar busca para garantir que todos os registros estejam vis√≠veis
          linhaReferencia = null;
          idDataTable.search("");
        }
      }
      // Fun√ß√£o para baixar CSV
      function baixarCSV() {
        // garante que n√£o h√° filtro aplicado
        limparBusca();

        let csv = "";

        // Cabe√ßalho
        csv += `Tipo,Equipamento,Ativo,Protocolo,Azimute,Latitude,Longitude\n`;

        // Linhas
        tabelaGeo.forEach(p => {
          const linha = [
            `${p.Tipo}`,
            `${p.Equipamento}`,
            `${p.Ativo}`,
            `${p.Protocolo}`,
            `${p.Azimute}`,
            `${p.Latitude}`,
            `${p.Longitude}`
          ].join(",");
          csv += linha + "\n";
        });

        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "tabelaGeorreferenciamento.csv";
        link.click();
      }


    // Fun√ß√£o para plotar marcador no mapa com mais informa√ß√µes
    function plotarNoMapa(lat, lng, tipo, equipamento, azimute,index) {
      // Armazena a linha de refer√™ncia
      linhaReferencia = equipamento;
     
      if(!lat || !lng) return;

     
      lat = getPrimeiraOcorrencia(lat.toString());
      lng = getPrimeiraOcorrencia(lng.toString());

      
      L.circleMarker([lat, lng], {
        radius: 8,
        color: '#b71c1c',
        fillColor: '#e53935',
        fillOpacity: 0.9
      })
      .addTo(map)
      .bindPopup(`
                  <strong style="color: darkblue;">${tipo}</strong>
                  <ul style="padding-left: 15px; margin: 0;">
                    <li>${equipamento}</li>
                    <li>Latitude: ${lat}</li>
                    <li>Longitude: ${lng}</li>
                    ${azimute ? `<li>Azimute: ${azimute}</li>` : ""}
                  </ul>
                `)
      .openPopup();

      map.setView([lat, lng], 15);
        // ‚úÖ Fecha o painel lateral
      const painel = document.getElementById("painelTabela");

      if (painel) {
        painel.style.display = "none";
      }
    }

    // Controle Leaflet para abrir/fechar painel

    L.Control.Excel = L.Control.extend({
        onAdd: function(map) {
          const btn = L.DomUtil.create(
            "button",
            "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
          );

          btn.innerHTML = `
            <img src="https://cdn-icons-png.flaticon.com/512/2535/2535554.png" 
                alt="Coordenadas" style="width:20px;height:20px;">
          `;
          btn.title = "Apresenta/oculta tabela georreferenciamento";

          L.DomEvent.disableClickPropagation(btn);

          btn.onmousedown = function () {
            btn.style.boxShadow = "0 2px #0D47A1";
            btn.style.transform = "translateY(2px)";
          };
          btn.onmouseup = function () {
            btn.style.boxShadow = "0 4px #0D47A1";
            btn.style.transform = "translateY(0)";
          };

          btn.onclick = function() {
            const painel = document.getElementById("painelTabela");
            const wrapper = painel.querySelector(".table-wrapper");
            const displayAtual = window.getComputedStyle(painel).display;

            if (displayAtual === "none") {
              // üëâ abrir painel
              if (!tabelaGeo || tabelaGeo.length === 0 || (tabelaGeo.length > 0 && !tabelaGeo[0].Tipo)) {
              
                // se tabelaGeo estiver vazio, chama diretamente a fun√ß√£o de upload
                mostrarAlerta('Fa√ßa Upload do arquivo com as coordenadas.')
           
                return; // n√£o abre painel vazio
              }

              const htmlTabela = gerarTabelaHTML(tabelaGeo);
              wrapper.innerHTML = htmlTabela;
              painel.style.display = "block";

              setTimeout(() => {
                const tabelaEl = document.querySelector("#containerTabelaGeo"); // pega a TAG <table>
 
                if (!tabelaEl) return;

                if (idDataTable) idDataTable.destroy();  
                painel.style.display = "block";             
                idDataTable = new DataTable(tabelaEl, {
                  searchable: true,
                  sortable: true,
                  perPage: 10, // n√∫mero inicial de registros por p√°gina
                  perPageSelect: [10,15, 30, 50, 100], // op√ß√µes que aparecem no seletor

                  fixedHeight: false, // for√ßa respeitar o perPage
                  labels: {
                    placeholder: "üîç Buscar...",
                    perPage: "{select} registros por p√°gina",
                    noRows: "Nenhum registro encontrado",
                    info: "Mostrando {start} at√© {end} de {rows} registros"
                  }
                });
  
                if (linhaReferencia) {
                  idDataTable.search(linhaReferencia);
                }
              }, 250);

            } else {
              painel.style.display = "none";
            }
          };

          return btn;
        },
        onRemove: function(map) {}
      });

      map.addControl(new L.Control.Excel({ position: 'topright' }));

      //Fun√ß√£o inicializar mapa

      function initMapa() {
        if(isTracing) console.log('InitMapa');
          // Inicializa o mapa com OpenStreetMap
          map = L.map("map", {
            center: [-15.7797 , -47.9297], // Bras√≠lia
            zoom: 7,                 // zoom inicial
            minZoom: 1,               // zoom m√≠nimo permitido
            maxZoom: 18,              // zoom m√°ximo permitido            
            layers: [baseMaps["OpenStreetMap"]]
          });     
          map.setView([-15.7797, -47.9297], 6)
          /* Valores mais comuns de zoom
              üîπ Valores mais comuns
              Zoom	Descri√ß√£o
              0	Mundo inteiro
              5	Pa√≠s
              10	Cidade
              13	Bairro
              16	Quadras
              18	Rua
              20‚Äì22	Detalhe m√°ximo (depende do mapa)
          */
          ////////////////////////////////
          
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors'
          }).addTo(map);
          
          // Camada base Sat√©lite (Esri)
          /*
          L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles ¬© Esri &mdash; Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
          }).addTo(map);
          */

   
          // Fun√ß√£o de clique no mapa
          function onMapClick(e) {
            if (!clickEnabled) return;

            const lat = e.latlng.lat;
            const lng = e.latlng.lng;

            const centro = map.getCenter();
            const azimute = calcularAzimute(centro.lat, centro.lng, lat, lng);

            const canvas = gerarGraficoAzimute(azimute);

            const container = document.createElement("div");
            container.innerHTML = `
              <b>Coordenadas:</b><br>
              Latitude: ${lat.toFixed(6)}<br>
              Longitude: ${lng.toFixed(6)}<br>
              Azimute em rela√ß√£o ao norte: ${azimute.toFixed(2)}¬∞
              <br><br>
            `;
            container.appendChild(canvas);

            // üëâ bot√£o para copiar
            const btnCopiar = document.createElement("button");
            btnCopiar.textContent = "üìã Copiar coordenadas";
            btnCopiar.style.cssText = "margin-top:8px; padding:4px 8px; cursor:pointer;";
            btnCopiar.onclick = () => {
              const texto = `${lat.toFixed(6)} \t ${lng.toFixed(6)}`;
              navigator.clipboard.writeText(texto).then(() => {
                btnCopiar.textContent = "‚úÖ Copiado!";
                setTimeout(() => btnCopiar.textContent = "üìã Copiar coordenadas", 1500);
              });
            };
            container.appendChild(btnCopiar);

            L.popup()
              .setLatLng(e.latlng)
              .setContent(container)
              .openOn(map);
          }

          // Controle personalizado click no mapa para as coordenadas
          const ToggleCoordsControl = L.Control.extend({
            options: { position: "topright" },

            onAdd: function () {
              const container = L.DomUtil.create("div", "leaflet-bar leaflet-control leaflet-control-custom");

              // √çcone FontAwesome (ex.: localiza√ß√£o cruzada)
              container.innerHTML = '<i class="fa-solid fa-crosshairs"></i>';
              container.style.backgroundColor = "white";
              container.style.cursor = "pointer";
              container.style.fontSize = "18px";
              container.style.textAlign = "center";
              container.style.lineHeight = "30px";
              container.style.width = "20px";
              container.style.height = "27px";

              container.onclick = function () {
                if (clickEnabled) {
                  map.off("click", onMapClick);
                  clickEnabled = false;
                  container.style.backgroundColor = "white"; // desligado
                } else {
                  map.on("click", onMapClick);
                  clickEnabled = true;
                  container.style.backgroundColor = "#cce5ff"; // ligado
                }
              };

              return container;
            }
          });

          // Adicionar controle ao mapa
          map.addControl(new ToggleCoordsControl());


          // cria controle de upload dentro do mapa
          const UploadControl = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function () {
              // bot√£o estilizado
              const btn = L.DomUtil.create(
                "button",
                "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
              );

              btn.innerHTML = ` <label for="fileCSV" title="Upload de arquivo CSV" style="cursor:pointer;">
                <img src="https://cdn-icons-png.flaticon.com/512/724/724933.png" alt="Upload CSV" style="width:20px;height:20px;">
                  </label>
              <input type="file" id="fileCSV" accept=".csv,text/csv"> `;

              // evita arrastar o mapa ao clicar
              L.DomEvent.disableClickPropagation(btn);

              // efeito de clique (pressionado)
              btn.onmousedown = function () {
                btn.style.boxShadow = "0 2px #0D47A1";
                btn.style.transform = "translateY(2px)";
              };
              btn.onmouseup = function () {
                btn.style.boxShadow = "0 4px #0D47A1";
                btn.style.transform = "translateY(0)";
              };

              // a√ß√£o ao selecionar arquivo
              const inputFile = btn.querySelector("#fileCSV");
              inputFile.addEventListener("change", function (event) {
                const file = event.target.files[0];
                if (file) {
                  // üëâ aqui voc√™ chama sua fun√ß√£o para processar o CSV
                 // processarCSV(file);
                }
              });
              

              return btn;
            }
          });

          map.addControl(new UploadControl());

          // evento de upload
          document.getElementById("fileCSV").addEventListener("change", (event) => {
            const arquivo = event.target.files[0];
            if (!arquivo) return;

            const reader = new FileReader();
            reader.onload = () => {
              tabelaGeo = csvParaJson(reader.result);

              //settabelaGeo(tabelaGeo);
              event.target.value = ""; // limpa para permitir re-sele√ß√£o
            };
            reader.readAsText(arquivo);
          });

          //Popup seletor de tipo de mapa. Aparece no canto superior direito
 
          const MapSelector = L.Control.extend({
            options: { position: "topright" },
            onAdd: function () {
              // cria bot√£o com estilo .btn-acao e .btn-fechar
              const container = L.DomUtil.create(
                "button",
                "leaflet-bar leaflet-control leaflet-control-custom btn-acao btn-fechar"
              );

              container.innerHTML = `
                <img src="https://cdn-icons-png.flaticon.com/512/854/854878.png" 
                    alt="Salvar csv" style="width:20px;height:20px;">
              `;

              // efeito ao clicar (pressionado)
              container.onmousedown = function () {
                container.style.boxShadow = "0 2px #0D47A1";
                container.style.transform = "translateY(2px)";
              };
              container.onmouseup = function () {
                container.style.boxShadow = "0 4px #0D47A1";
                container.style.transform = "translateY(0)";
              };

              // evita arrastar o mapa ao clicar no controle
              L.DomEvent.disableClickPropagation(container);

              // vari√°veis de controle do popup
              let popupAberto = false;
              let popupRef = null;

              // a√ß√£o ao clicar no bot√£o
              container.onclick = function () {
                if (!popupAberto) {
                  let html = "<b>Selecione o mapa:</b><br>";
                  Object.keys(baseMaps).forEach(nome => {
                    const icon = baseMapIcons[nome] || "üó∫Ô∏è"; // fallback
                    html += `<div style="cursor:pointer; margin:3px; color:blue;" 
                              onclick="window.setBaseMap('${nome}')">${icon} ${nome}</div>`;
                  });
                  popupRef = L.popup({ maxWidth: 300 })
                    .setLatLng(map.getCenter())
                    .setContent(html)
                    .openOn(map);
                  popupAberto = true;
                } else {
                  map.closePopup(popupRef);
                  popupAberto = false;
                }
              };

              return container;
            }
          });

          map.addControl(new MapSelector());
          // Fun√ß√£o global para trocar mapa base
          window.setBaseMap = function (nome) {
            map.eachLayer(layer => {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            baseMaps[nome].addTo(map);
          };
          const ¬†precisaoAgrupamentoMinimo = 50;
          const ¬†precisaoAgrupamentoMaximo = 150;
          // Grupo de clusters
          markersCluster = 


                          L.markerClusterGroup({
                            spiderfyOnEveryZoom: false,        // n√£o fechar ao dar zoom
                            removeOutsideVisibleBounds: false, // mant√©m clusters fora da √°rea vis√≠vel
                            disableClusteringAtZoom: null,     // mant√©m agrupamento
                            maxClusterRadius: 4 //zoom => zoom < 10 ? precisaoAgrupamentoMaximo : precisaoAgrupamentoMinimo
                          });                                      
     
                                    
          // ‚úÖ Aqui voc√™ registra o evento
          map.on("click", onMapClick);

      }
  

        // Fun√ß√£o que converte CSV em JSON
        function csvParaJson(csvTexto) {
       
          const linhas = csvTexto.trim().split("\n");
          const cabecalhos = linhas[0].split(",").map(h => h.trim());

          return linhas.slice(1).map(linha => {
            const valores = linha.split(",").map(v => v.trim());
            const objeto = {};
            cabecalhos.forEach((chave, i) => {
              objeto[chave] = valores[i];
            });
            return objeto;
          });
        }

        function lerCSV(arquivo) {
          if(isTracing) console.log('lerCSV')       
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                const json = csvParaJson(reader.result);
                tabelaGeo = json;
                resolve(json);
              } catch (e) { 
             
                reject(e); }
            };
            reader.onerror = () => {
              

             reject("Erro ao ler arquivo");}
            reader.readAsText(arquivo);
          });
        }

        document.getElementById("fileCSV").addEventListener("change", async (event) => {
            if(isTracing) console.log('getElementById');
            const arquivo = event.target.files[0];
            if (!arquivo) return;
          
            await lerCSV(arquivo);

            plotartabelaGeoMapa(tabelaGeo);
        });

        function getArrayIcones() {
          let arrayIcones = [
                              {tipo: "Recinto (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/128/684/684908.png" },
                              {tipo: "Balan√ßa (ponto)" , url: "escala-industrial.png",icone:"https://cdn-icons-png.flaticon.com/512/8248/8248483.png" },
                              {tipo: "Catraca e similares (ponto)", url: "torniquetes.png",icone:"https://cdn-icons-png.flaticon.com/512/1185/1185509.png" },
                              {tipo: "C√¢mera (ponto)", url: "camera-ctv.png",icone: "https://cdn-icons-png.flaticon.com/512/10073/10073813.png"},
                              {tipo: "Port√£o, gate e similares (ponto)", url: "boom_gate2.png",icone:"https://cdn-icons-png.flaticon.com/512/4999/4999239.png" },
                              {tipo: "Port√™iner (ponto)", url: "portainer.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                              
                              {tipo: "Recinto (pol√≠gono)", url: "area.png",icone: "https://cdn-icons-png.flaticon.com/512/12355/12355988.png"},
                              {tipo: "Scanner (ponto)", url:  "barcode-scanner_2605593.png",icone: "https://cdn-icons-png.flaticon.com/512/4652/4652615.png"},
                              {tipo: "√Årea de armazenamento de lotes (pol√≠gono)", url: "icons8-armaz√©m-80.png",icone:"https://cdn-icons-png.flaticon.com/512/754/754877.png" },
                              {tipo: "√Årea de confer√™ncia f√≠sica (pol√≠gono)", url: "peso.png",icone: "https://cdn-icons-png.flaticon.com/512/16355/16355158.png"},
                              {tipo: "√Årea de posicionamento de cont√™ineres (pol√≠gono)", url: "Container_Red_icon-icons.com_54903.png",icone:"https://cdn-icons-png.flaticon.com/512/1254/1254256.png" },
                              {tipo: "√Årea de posicionamento de ve√≠culos (pol√≠gono)", url: "caminh√£o.png",icone: "https://cdn-icons-png.flaticon.com/512/8397/8397505.png"},                               
                              {tipo: "Tanque de armazenamento (ponto)", url: "TanqueArmazenamento.jpg",icone: "https://cdn-icons-png.flaticon.com/512/5755/5755651.png"},
                              {tipo: "Silo (ponto)", url: "silo.png",icone: "https://cdn-icons-png.flaticon.com/512/2078/2078261.png"},
                              {tipo: "√Årea de controle de carga solta (pol√≠gono)", url: "cargaSolta.png",icone: "https://cdn-icons-png.flaticon.com/512/4829/4829649.png"},
                              {tipo: "Port√™iner Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},
                              {tipo: "Port√™iner, Shiploader ou similares (ponto/pol√≠gono)", url: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png",icone: "https://cdn-icons-png.flaticon.com/512/11860/11860966.png"},

                              //{tipo: "", url: ".png"},
                                //{tipo: "", url: ".png"},                                                                                                

                            ]
          return arrayIcones                  
       }

        function getIcone(icone,azimute) {

            let arrayIcones = getArrayIcones();
            let retorno = 'https://cdn-icons-png.flaticon.com/512/7199/7199765.png';
           
            for (let i = 0; i < arrayIcones.length; i++) {
           
              if (arrayIcones[i].tipo === icone) {
                  retorno = arrayIcones[i].icone
                  
                  break;
              }           
            }
            //Se for c√¢mera e n√£o h√° azimute, entendemos ser c√¢mera dome
            //Retornar endere√ßo do √≠cone de uma dome  
            if(icone.search('C√¢mera')>=0 && !azimute)
               retorno = 'https://cdn-icons-png.flaticon.com/512/10005/10005664.png';
            return retorno;   
       }

        function getPrimeiraOcorrencia(coord) {

           if(!coord) return 0.;
           let vetor = coord.toString().split( ' - ')


           return vetor[0]

       }
        // Fun√ß√£o que desenha gr√°fico de azimute em canvas

        function gerarGraficoAzimute(azimute) {
          const canvas = document.createElement("canvas");
          canvas.width = 220;
          canvas.height = 220;
          const ctx = canvas.getContext("2d");

          // fundo
          ctx.fillStyle = "#f9f9f9";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // c√≠rculo da b√∫ssola
          ctx.beginPath();
          ctx.arc(110, 110, 80, 0, 2 * Math.PI);
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2;
          ctx.stroke();

          // √¢ngulos de 45 em 45 graus
          ctx.fillStyle = "black";
          ctx.font = "bold 8px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";

          for (let angle = 0; angle < 360; angle += 45) {
            const rad = (angle - 90) * Math.PI / 180;
            const x = 110 + 70 * Math.cos(rad);
            const y = 110 + 70 * Math.sin(rad);
            ctx.fillText(angle + "¬∞", x, y);
          }

          // dire√ß√µes principais N, S, L, O em azul, fora do c√≠rculo
          ctx.fillStyle = "blue";
          ctx.font = "bold 14px Arial";

          const offset = 95; // raio maior para jogar as letras para fora

          // Norte (0¬∞)
          ctx.fillText("N", 110, 110 - offset);
          // Sul (180¬∞)
          ctx.fillText("S", 110, 110 + offset);
          // Leste (90¬∞)
          ctx.fillText("L", 110 + offset, 110);
          // Oeste (270¬∞)
          ctx.fillText("O", 110 - offset, 110);

          // desenhar linha do azimute
          const radAz = (azimute - 90) * Math.PI / 180;
          const xAz = 110 + 70 * Math.cos(radAz);
          const yAz = 110 + 70 * Math.sin(radAz);

          ctx.beginPath();
          ctx.moveTo(110, 110);
          ctx.lineTo(xAz, yAz);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 3;
          ctx.stroke();

          return canvas;
        }

      
  
      // Fun√ß√£o para calcular azimute em rela√ß√£o ao norte verdadeiro
        function calcularAzimute(lat1, lon1, lat2, lon2) {
          // Converter graus para radianos
          const toRad = deg => deg * Math.PI / 180;
          const toDeg = rad => rad * 180 / Math.PI;

          const dLon = toRad(lon2 - lon1);
          const lat1Rad = toRad(lat1);
          const lat2Rad = toRad(lat2);

          // F√≥rmula de azimute (bearing)
          let y = Math.sin(dLon) * Math.cos(lat2Rad);
          let x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                  Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

          let brng = toDeg(Math.atan2(y, x));
          return (brng + 360) % 360; // normalizar para 0‚Äì360¬∞
        }

        // Fun√ß√£o que calcula o cone e retorna o array de coordenadas
        function calcularCone(lat, lon, azimute, abertura, altura) {
          var rad = azimute * Math.PI / 180;
          var half = abertura / 2 * Math.PI / 180;

          var lat1 = lat + altura * Math.cos(rad - half);
          var lon1 = lon + altura * Math.sin(rad - half);

          var lat2 = lat + altura * Math.cos(rad + half);
          var lon2 = lon + altura * Math.sin(rad + half);

          // retorna o array de tabelaGeo do tri√¢ngulo
          return [[lat, lon], [lat1, lon1], [lat2, lon2]];
        }
       
        function getCoordenada(coordenada) {
             
          if(typeof coordenada === 'string') coordenada = parseFloat(coordenada)
          return coordenada;
        }
 
        function contarRecintos(tabelaGeo) {
            let contador = 0;
            for (let ix = 0; ix < tabelaGeo.length; ix++) {
              if (tabelaGeo[ix].Tipo && tabelaGeo[ix].Tipo.search('Recinto') !== -1) {
                contador++;
              }
            }
            return contador;
        }

        function settabelaGeo(tabelaGeo){
            tabelaGeo = tabelaGeo;
        }  

        function plotartabelaGeoMapa(tabelaGeo) {
          if(isTracing) console.log('plotartabelaGeoMapa',tabelaGeo);

    
 
            // √çcones da web
            arrayIcones = []
 
   
            //Conta quantos Recintos h√° em tabelaGeo
            let qtdRecintos = contarRecintos(tabelaGeo);   
                            
            //Percorre a tabela de ativos                          
            for (let ix = 0; ix < tabelaGeo.length; ix++) {  
          
              let p = tabelaGeo[ix]
              
              if(p.Ativo != 'true') continue

              //Validar se √© ponto ou √°rea
              //Ponto n√£o pode ter pol√≠gono no p.Tipo
              let iconURL = getIcone(p.Tipo,p.Azimute)

              const customIcon = L.icon({
                iconUrl: iconURL,
                iconSize: [32, 32],
                iconAnchor: [16, 32],
                popupAnchor: [0, -32]
                });
                  
              latitude  = ''
              longitude = ''

              if(p.Tipo.search('pol√≠gono') >=0) {
          

                  let arrayLatitude = p.Latitude.split(' - ')
                  let arrayLongitude = p.Longitude.split(' - ')

                  let ultimaLatitude  = getCoordenada(arrayLatitude[0]); 
                  let UltimaLongitude = getCoordenada(arrayLongitude[0]) ;         
                  for (let lx = 0; lx < arrayLatitude.length; lx++) {  

                      if (p.Tipo.search('Recinto')>=0) { 
                          poligonoRecinto.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          //Para fechar o pol√≠gono
                          if(lx + 1 === arrayLatitude.length) {
                            poligonoRecinto.push([ultimaLatitude, UltimaLongitude]);
                          }
                      }

                      areas.forEach(area => {
                     
                          if (p.Tipo.toLocaleLowerCase().search(area.titulo.toLocaleLowerCase()) >= 0) {
                            area.coords.push([getCoordenada(arrayLatitude[lx]) , getCoordenada(arrayLongitude[lx])]);
                          }
                      });  

                  }

              } 
              if(p.Tipo.search('ponto') >=0) {
                  if(p.Latitude === '') continue; 
                  latitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)));
                  longitude = parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)));
                  let azimute = p.Azimute ? p.Azimute : 0.

                  //Marco Zero - Recinto
                  if(qtdRecintos===1) {
                      // Define o t√≠tulo da p√°gina
                      document.getElementById("map-title").innerHTML = p.Equipamento; 
                  }
                    if(p.Tipo.search('Recinto')>=0) {
                     
                      //var markers = L.markerClusterGroup();
                      var markers = L.markerClusterGroup();
                      markers.addLayer(L.marker([latitude, longitude]).//bindPopup(p.Equipamento));
                      bindPopup("<strong style='color:blue;'>" + p.Equipamento + "</strong>"));

                      map.addLayer(markers);
                      continue;

                    }   
                  //Se for c√¢mera e houver azimute
                  if(p.Tipo.search('C√¢mera') >=0 && p.Azimute ){
                      // Usa a fun√ß√£o para obter coordenadas e desenhar no mapa
                        var coordsCone = calcularCone(latitude, longitude, azimute, 40, 0.0005);
                        /*
                    Op√ß√µes principais
                    color: cor da borda.
                    weight: espessura da borda.
                    dashArray: define se a linha √© cont√≠nua ou tracejada. Exemplo: "10, 5" (10px tra√ßo, 5px espa√ßo).
                    fillColor: cor interna do pol√≠gono.
                    fillOpacity: opacidade do preenchimento (0 = transparente, 1 = opaco).
                    opacity: opacidade da linha de contorno.
                        */
                    L.polygon(coordsCone, {
                      color: 'blue',        // cor da linha
                      weight: 1,            // espessura da linha
                      dashArray: '5, 5',    // tra√ßos e espa√ßos (5px tra√ßo, 5px espa√ßo)
                      fillColor: 'blue',    // cor de preenchimento
                      fillOpacity: 0.09      // opacidade do preenchimento
                    }).addTo(map);



                  }
                  // Marker com popup contendo texto + gr√°fico
                  
                  let marker = L.marker([latitude, longitude], { icon: customIcon })
                    .bindPopup(() => {
                      // conte√∫do textual
                      const div = document.createElement("div");
                      
                      div.innerHTML = `
                        <strong style="color: blue;">${p.Tipo}</strong>
                          <ul style="padding-left: 15px; margin: 0;">
                            <li>${p.Equipamento}</li>
                            <li>Latitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Latitude)))}</li>
                            <li>Longitude: ${parseFloat(getCoordenada(getPrimeiraOcorrencia(p.Longitude)))}</li>

                            ${p.Azimute ? `<li>Azimute: ${p.Azimute}</li>` : ""}
                          </ul>
                      
                      `;

                      if (p.Azimute) {
                        div.appendChild(gerarGraficoAzimute(p.Azimute));
                      }
                      return div;
                    });

                  markersCluster.addLayer(marker);
                
               }
            }
             
            if(markersCluster) map.addLayer(markersCluster);

            const marcadorVermelho = L.icon({
              iconUrl: 'https://cdn-icons-png.flaticon.com/128/1397/1397898.png',
              shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
              iconSize: [25, 41],
              iconAnchor: [12, 41],
              popupAnchor: [1, -34],
              shadowSize: [41, 41]
            });

              // Adiciona marcador na primeira coordenada
            if(poligonoRecinto.length >0) {  
                  const primeiraCoord = poligonoRecinto[0]; // pega o primeiro ponto
                    // Pol√≠gono do Recinto
                    L.polyline(poligonoRecinto, {
                      color: rodapeInfo[1].cor,
                      weight: 4,
                      opacity: 0.8
                    }).addTo(map)
                      .bindTooltip("<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' style='vertical-align:middle;margin-right:5px;'/>" +
                                      "<strong style='color:darkred;'>Pol√≠gono do Recinto</strong>",
                      {
                        permanent: false,
                        direction: "center",
                        className: "tooltip-transparent"
                      });
                   L.marker(primeiraCoord, { icon: marcadorVermelho })
                      .addTo(map)
                      .bindPopup(
                        "<strong style='color:darkred;'>Marco 0 do Recinto</strong>",
                        { className: 'popup-transparente' }
                      );


              }  

              areas.forEach(area => {
                if (area.coords.length >= 1) {
                  //const info = getRodapeInfo(area.titulo);
                  const primeiraCoord = area.coords[0]; // pega o primeiro ponto
                  L.polygon(area.coords, {color: area.cor})
                    .addTo(map)

                    .bindTooltip("<img src='https://cdn-icons-png.flaticon.com/512/15724/15724751.png' width='20' style='vertical-align:middle;margin-right:5px;'/>" +
                              "<strong style='color:darkred;'>"+area.titulo+"</strong>",                    
                    { 
                                 permanent: false, 
                                 direction: "top" , // centralizado
                                 className: "polygon-label" // opcional para estilizar via CSS
                                              })
                    
                    .openTooltip();

                    L.marker(primeiraCoord, { icon: marcadorVermelho })
                      .addTo(map)
                      .bindPopup(
                        "<strong style='color:darkred;'>"+area.titulo+"</strong>",
                        { className: 'popup-transparente' }
                      );
                }
              });                            

            //Abre os tabelaGeo de um cluster
            if(markersCluster)
                markersCluster.on('clusterclick', function (a) {
                  a.layer.spiderfy(); // abre o cluster
                  a.originalEvent.preventDefault(); // evita comportamento padr√£o
                });

            if(markersCluster)
               markersCluster.on('clusteringend', function () {
                    markersCluster.getLayers().forEach(layer => {
                      if (layer.spiderfy) layer.spiderfy();
                    });
                  });

            // Ajusta o zoom para mostrar tudo
     
            if(!markersCluster.getBounds().isValid()) {
              var bounds = L.latLngBounds([[-15.78, -47.93], [-15.75, -47.90]]);
              
              map.fitBounds(bounds);  
              map.setZoom(6);    
            } else 
            if(markersCluster)
               map.fitBounds(markersCluster.getBounds(), { padding: [30, 30] });
        }
 

</script> 

</body>
</html>